-----------------------------------------------------------------------
-- Skirmish script specific to the Italy campaign.
--
-- Win conditions and objectives associated with Italy campaign skirmish battles.
--
-- (c) Relic Entertainment 2020
-----------------------------------------------------------------------

import("anvil.scar")
import("ui/ticket_ui.scar")

import("test/proto_easymode.scar")
import("sp/skirmish_affectors.scar")
import("sp/lighting.scar")

import("winconditions/ticket_vp.scar")
import("winconditions/ticket_entity_loss.scar")
import("winconditions/ticket_territory.scar")

import("winconditions/win_tickets.scar")
import("winconditions/win_destroy_hq.scar")
import("winconditions/win_surrender.scar")


-----------------------------------------------------------------------
-- Scripting framework (see  http://relicwiki/display/EE/Core+SCAR+Initialization+Framework)
-----------------------------------------------------------------------

Core_RegisterModule("Skirmish")

-----------------------------------------------------------------------
-- Constants
-----------------------------------------------------------------------

local campaign_data_key = "campaign"	-- name of campaign data store
local deferred_campaign_data = {}		-- info about the current skirmish options to defer setting in the datastore until the skirmish is completed 
local ui_popup_duration = 8				-- amount of time to wait to end the match after the final objective popup is triggered
local mission_rule = 4					-- ID to associate with rule group that should be removed when a win condition triggers
local bonus_rule = 5					-- ID to associate with rule group that should be removed when tickets are low
local modes = {							-- available skirmish modes ("rescue" is a special case and therefore not included)
	player_attacking = {
		"territory",
		"rout",
		"cutoff",
		"knockout",
		"fixed_force",
	},
	player_defending = {
		"victory_point",
		"cutoff",
		"fixed_force",
	}
}
local win_condition_triggered = false -- bool to ensure OnWinConditionTriggered only gets processed once

local default_unit_sbp = {		-- TODO: Generate these dynamically based on squad type
	germans = SBP.GERMAN.PIONEER_GER,
	americans = SBP.AMERICAN.SCOUT_US,
	british = SBP.BRITISH.SAPPER_UK,
}
local basic_infantry_sbp = {	-- TODO: Generate these dynamically based on squad type
	germans = SBP.GERMAN.GRENADIER_GER,
	americans = SBP.AMERICAN.RIFLEMEN_US,
	british = SBP.BRITISH.TOMMY_UK,
}

-----------------------------------------------------------------------
-- Callbacks (in order they are typically called)
-----------------------------------------------------------------------

-- Called by OnInit() in core.scar at start of initialization sequence. 
function Skirmish_OnInit()

	print("Skirmish_OnInit() - "..Game_GetScenarioFileName())
	
	win_condition_triggered = false
	
	-- Tell the difficulty system to use the skirmish difficulty tuning
	-- (This value is still tuned within difficulty_tuning.scar, but can be
	--  moved)
	DifficultyTuning_SetDifficultyTuningOverride(t_skirmish_difficulty_tuning)
	DifficultyTuning_SetModifyAllyPlayer(true)

	_skirmish = {
		player_attacking = Misc_IsCommandLineOptionSet("attack"),
		victory_points = EGroup_CreateIfNotFound("eg_vps"),
		options = {},
		objectives = {},
		company = {},	-- company type
		prefabs = {},	-- AI prefabs
		weapon_drop_squads = {},
		narrative = {
			--attack_hq = {
			--intro1 = "skirmish_attack_hq_intro1",--"The enemy has a defensive advantage, but we have the initiative of attack."
			--intro2 = "skirmish_attack_hq_intro2",--"Seek out and destroy their headquarters."		
			--victory = "skirmish_attack_victory",-- "Congratulations, you won the day."
			--defeat = "skirmish_defeat", 		-- "We lost this battle, but not the war. Retreat and regroup."
			--obj_text = 11192776, 			-- "Destroy the enemy headquarters"
			--},
			attack_cutoff = {
				vo_intro1 = "skirmish_cutoff_attack_intro1",--"The enemy has the defensive advantage, but we have the initiative of attack."
				vo_intro2 = "skirmish_cutoff_intro2",		--"If we can isolate their base then we can force a retreat."
				vo_victory = "skirmish_attack_victory",		-- "Congratulations, you won the day."
				vo_defeat = "skirmish_defeat", 				-- "We lost this battle, but not the war. Retreat and regroup."
				vo_obj_done = "skirmish_cutoff_hold", 	-- "We have them surrounded. Now hold the ground until their morale cracks."
				vo_obj_fail = "skirmish_cutoff_fail", 	-- "The enemy broke through. Bring up more infantry and close the pocket around their base."
				vo_subobj_start = "skirmish_cutoff_breakout",	-- "The enemy has cut off our base. Break out or the battle is lost!"
				obj_text1 = 11196268,		-- "Capture all territory around enemy base"
				obj_text2 = 11196269,		-- "Hold all territory around enemy base"
				subobj_text = 11196271,		-- "Break the enemy encirclement"
			},
			knockout = {
				intro1 = "skirmish_knockout_intro1",-- "We are facing a battle-hardened enemy. The only way to defeat them is to inflict enough damage to break their morale."
				intro2 = "skirmish_knockout_intro2",-- "Be warned: the enemy will try to do the same to us."
				victory = "skirmish_attack_victory",-- "Congratulations, you won the day."
				defeat = "skirmish_defeat", 		-- "We lost this battle, but not the war. Retreat and regroup."
				obj_text = 11192099,			-- "Inflict damage to break enemy morale"
			},
			rout = {
				intro1 = "skirmish_rout_intro1",	-- "There are three points that are key to victory in this area. We can demoralize the enemy and trigger a rout if we can capture and hold all three at once."
				intro2 = "skirmish_rout_intro2",	-- "I'll wager the Germans will try to do the same."
				victory = "skirmish_attack_victory",-- "Congratulations, you won the day."
				defeat = "skirmish_defeat", 		-- "We lost this battle, but not the war. Retreat and regroup."
				obj_text = 11192100,				-- "Control victory points to exhaust enemy reserves"
				subobj1_text = 11192101,			-- "Capture all victory points to trigger a rout"
				subobj2_text = 11192102,			-- "Defend all victory points to trigger a rout"
				subobj3_text = 11192103,			-- "Neutralize a victory point to prevent defeat"
			},
			territory = {
				intro1 = "skirmish_territory_intro1",--"The plan of attack is simple: hold more territory than the enemy in order to bleed their reinforcements dry."
				intro2 = "skirmish_territory_intro2",--"Move fast - we have the initiative but they have the defensive advantage."
				victory = "skirmish_attack_victory", --"Congratulations, you won the day."
				defeat = "skirmish_defeat", 		 --"We lost this battle, but not the war. Retreat and regroup."
				obj_text = 11192106,			 --"Control territory to exhaust enemy reserves"
			},
			--defend_hq = {
			--intro1 = "skirmish_defend_hq_intro1",--"The enemy is preparing to attack our base. We have the defensive advantage so we can hold them for a while."
			--intro2 = "skirmish_defend_hq_intro2",--"However, if we can eliminate their headquarters then we can thwart their attack."
			--victory = "skirmish_attack_victory", --"Congratulations, you won the day."
			--defeat = "skirmish_defeat", 		 --"We lost this battle, but not the war. Retreat and regroup."
			--obj_text = 11192105,				 --"Village Defense"
			--subobj1_text = 11192776, 			 --"Destroy the enemy headquarters"
			--},
			defend_cutoff = {
				vo_intro1 = "skirmish_cutoff_defend_intro1",--"We may be on the defense, but that just means we're in a better position to bring the fight to the enemy."
				vo_intro2 = "skirmish_cutoff_intro2",--"If we can isolate their base then we can force a retreat."
				vo_victory = "skirmish_attack_victory",		-- "Congratulations, you won the day."
				vo_defeat = "skirmish_defeat", 				-- "We lost this battle, but not the war. Retreat and regroup."
				vo_obj_done = "skirmish_cutoff_hold", 	-- "We have them surrounded. Now hold the ground until their morale cracks."
				vo_obj_fail = "skirmish_cutoff_fail", 	-- "The enemy broke through. Bring up more infantry and close the pocket around their base."
				vo_subobj_start = "skirmish_cutoff_breakout", 	-- "The enemy has cut off our base. Break out or the battle is lost!"
				obj_text1 = 11196268,		-- "Capture all territory around enemy base"
				obj_text2 = 11196269,		-- "Hold all territory around enemy base"
				subobj_text = 11196271,		-- "Break the enemy encirclement"
			},				
			defend_vp = {
				intro1 = "skirmish_defend_vp_intro1",--"We're on the back foot here. There are three points on which our defense hinges - hold on to them and wear the enemy down. I expect they'll try to do the same."
				intro2 = "skirmish_defend_vp_intro2",--"However, the central point is the key target of the enemy assault. Protect it at all cost.
				victory = "skirmish_defend_victory", --"Congratulations, you blunted the enemy attack."
				defeat = "skirmish_defeat", 		 --"We lost this battle, but not the war. Retreat and regroup."
				obj_text = 11192100,			 --"Control victory points to exhaust enemy reserves"
				subobj_text = 11192107,			 --"Prevent enemy from capturing the key victory point"
			},
			rescue = {
				intro1 = "skirmish_rescue_start",
				damage1 = "skirmish_rescue_alliesDamaged1",
				damage2 = "skirmish_rescue_alliesDamaged2",
				damage3 = "skirmish_rescue_alliesDamaged3",
				allies_spotted = "skirmish_rescue_alliesSpotted",
				victory = "skirmish_rescue_success", 
				defeat = "skirmish_rescue_fail",
				hint_text = 11191914, 				-- "Allies"
				obj_text = 11191926,				--"Rescue the isolated troops"
				subobj1_text1 = 11198567,			--"Break the enemy encirclement"
				subobj1_text2 = 11191916,			--"Eliminate nearby squads"
				subobj2_text = 11191915,			--"Ally health"
			},
			attack_fixed = {
				intro1 = "skirmish_fixed_attack_intro1",	--"Our vanguard got too far ahead of the main force and blundered into the German defenses."
				intro2 = "skirmish_fixed_attack_intro2",	--"We have no choice but to begin the attack, but our reinforcements will be limited."
				victory = "skirmish_fixed_victory",			--"We broke their spirit! The Germans are in retreat."
				defeat = "skirmish_fixed_attack_defeat",	--"Fall back! The Germans stalled our attack."
				obj_text = 11220496,						--"Destroy enemy strongpoints"
			},
			defend_fixed = {
				intro1 = "skirmish_fixed_defend_intro1",	--"The Germans launched their attack before our main force could move into position."
				intro2 = "skirmish_fixed_defend_intro2",	--"Reinforcements are short so focus on defending our strongpoints. With luck, we can stop their advance."
				victory = "skirmish_fixed_victory", 		--"We broke their spirit! The Germans are in retreat."
				defeat = "skirmish_fixed_defend_defeat",	--"The Germans broke through our defenses! Fall back."
				obj_text = 11220500,				 		--"Defend strongpoints"
			},
			event_barrage = {
				alert = "skirmish_event_barrage_alert",		-- "The Germans are bombarding our front line! Take cover!"		
			},
			event_stuka = {
				alert = "skirmish_event_stuka_alert",		-- "Stukas! Take cover!"
			},
			event_reserves = {
				alert = "skirmish_event_reserves_alert",	-- "Radio intercepts reveal the enemy has committed their reserves."
			},
			event_goliath = {
				alert = "skirmish_event_goliath_alert",		-- "The enemy is reported to be using remotely controlled demolition charges as a last ditch defense. Stay alert!"
			},
			event_fallschirm = {
				alert = "skirmish_event_fallschirm_alert",	--"Enemy aircraft inbound! It seems the Luftwaffe still has some life left."
				start = "skirmish_event_fallschirm_start",	-- "Neutralize those Fallschirmjäger before they establish a foothold.",
				obj_text = 11194137,						-- "Eliminate Fallschirmjäger squads"
			},
			event_mines = {
				alert = "skirmish_event_mines_alert",--"Careful, it appears Jerry mined this area."
				start = "skirmish_event_mines_start",--"Clear the rest of those mines any way you can!"
				obj_text = 11194138,				 --"Clear enemy mines"
			},
			event_minelaying = {
				start = "skirmish_event_minelaying_start",	--"Division sent us a stockpile of mines they don't want to store any longer. Put them to good use."
				obj_text = 11201313,					 	--"Use mines to kill enemies"
			},
			event_supplies = {
				start = "skirmish_event_supplies_start",-- "That transport lost an engine and had to dump its cargo over enemy territory. Better that we recover it before the Germans."
				fail = "skirmish_event_supplies_fail",	-- "Darn it! The enemy recovered the munitions before our troops could reach them."
				obj_text = 11194139,					-- "Recover discarded munitions"
			},
			event_vip = {
				start = "skirmish_event_vip_start",--"Ah hell, the general's nephew was in that last batch of reinforcements. See that he gets enough combat experience to be promoted out of here. Just don't get him killed in the process."
				done = "skirmish_event_vip_done",--"The general's nephew got his stripes and will be on the next truck to the rear. We're not responsible for that ninny any longer."
				fail = "skirmish_event_vip_fail",--"Damn it, the general won't be pleased to hear he lost another nephew."
				obj_text = 11194140,			 --"Promote rifleman squad to rank 3"
			},
			event_sniper = {
				start = "skirmish_event_sniper_start",--"A crackshot sniper is active in this area. Local partisans have identified his usual positions, but we will have to flush him out."
				obj_text = 11194141,				  --"Find and kill the veteran sniper"
			},
			event_panzer = {
				start = "skirmish_event_panzer_start",--"The armor rolled out just in time. There's rumor that new Panther crews are training in this area. It's best we put a stop to that."
				obj_text = 11194142,				  --"Destroy enemy Panther before it reaches rank 1"
			},
			event_convoy = {
				start = "skirmish_event_convoy_start",--"A column of enemy tanks is returning to base. We should destroy the lot before the Germans can be repair, refuel, and return them to action."
				obj_text = 11194143,				  --"Destroy enemy tanks en route to their base"				
			},
			event_schreck = {
				start = "skirmish_event_schreck_start",--"Intel reports the Germans are field testing a new model of Panzerschreck projectile. Try to acquire some for evaluation ourselves."
				obj_text = 11194144,				   --"Capture a Panzerschreck"
			},
			event_battery = {
				start = "skirmish_event_battery_start",--"The Germans have heavy artillery support. Silence those guns!"
				obj_text = 11194145,				   --"Eliminate enemy artillery battery"
			},
			event_veteran = {
				start = "skirmish_event_veteran_start",--"Some enemy infantry have become adept at ambushing our troops. Eliminate them before they become any better or their tactics will soon spread."
				obj_text = 11194146,				   --"Kill veteran panzergrenadiers before they reach rank 3"
			},
			--event_inspection = {
			--start = "skirmish_event_inspect_start", 	  --"The General is on his way for a snap inspection. His truck should arrive any minute."
			--done = "skirmish_event_inspect_done",		  --"Good show, but I can't return to division in a truck full of bullet holes. I'll leave it here and see myself back.
			--fail = "skirmish_event_inspect_fail",		  --"Damn it, that truck was new last week. Now I'll have to walk back to division."				
			--sub1_start = "skirmish_event_inspect_1_start",--"Alright, let's make sure things are in order. First, let's havrounde a look at the munition supply."				 
			--sub2_start = "skirmish_event_inspect_2_start",--"Looks about as good as can be expected, given the circumstances. Bloody hell, I forgot my swagger stick - return to HQ." 				 
			--sub3_start = "skirmish_event_inspect_3_start",--"Now, let's check on the fuel situation. You know, my nephew joined a front line unit recently - I wonder if this might be it."
			--sub4_start = "skirmish_event_inspect_4_start",--"Everything seems in order here. Now, I have some commendations to award. Show me to the troops and I'll present the medals."
			--sub4_fail =  "skirmish_event_inspect_4_fail", --"Well, they won't be the last to die in this war."
			--sub5_start = "skirmish_event_inspect_5_start",--"That's it for the official business. Do my a favor, will you? I've served my whole career behind a desk - I'd love to see some action before this show ends."
			
			--obj_text = 11194147, --"General inspection"
			--sub1_text = 11194148,--"Inspect the munitions point"
			--sub2_text = 11194149,--"Return to HQ"
			--sub3_text = 11194150,--"Inspect the fuel point"
			--sub4_text = 11194151,--"Inspect the troops"
			--sub5_text = 11194152,--"Make the general a combat veteran"
			--},
			event_atgun = {
				start = "skirmish_event_atgun_start",	-- "We'll be up the creek if the Germans bring in their armor. Try to capture an enemy AT gun to bolster our defenses."
				obj_text = 11195241,				   	-- "Capture an enemy anti-tank gun"
			},
			event_fieldtest = {
				start = "skirmish_event_fieldtest_start",	-- "Division sent an anti-tank gun with some new field modifications. They want it tested in combat."
				done = "skirmish_event_fieldtest_done",		-- "Nice work. Those field modifications seem promising."
				fail = "skirmish_event_fieldtest_fail",		-- "It seems the gun shield wasn't thick enough. I'll report the loss of the prototype to Division. They won't be happy."
				obj_text = 11201294,						-- "Test modified anti-tank gun on enemy vehicles"
			},
			event_recovery = {
				start = "skirmish_event_recovery_start",	-- "One of our reconaissance vehicles struck a mine while patrolling behind enemy lines..."
				done = "skirmish_event_recovery_done",		-- "Good work, now get that vehicle back in service!"
				fail = "skirmish_event_recovery_fail",		-- "Such a waste of a good vehicle, but at least the radio was destroyed."
				obj_text = 11220495,						-- "Return armored car to friendly territory"
			},
		},
	}

	-- Cache players
	local_player = Game_GetLocalPlayer()
	for i = 1, World_GetPlayerCount() do
		local player = World_GetPlayerAt(i)
		if player ~= local_player then
			if Player_ObserveRelationship(local_player, player) == R_ALLY then
				allied_player = player
			else
				if not enemy_player then
					enemy_player = player
				else
					unused_player = player
				end
			end
		end
	end
	
	-- Cache victory points
	local eg = EGroup_CreateUnique()
	World_GetStrategyPoints(eg, true)
	EGroup_ForEach(eg, 
		function (egroup, index, entity)
			if Entity_IsVictoryPoint(entity) then
				EGroup_Add(_skirmish.victory_points, entity)
			end
		end)
	EGroup_Destroy(eg)
	

	-- Win condition override (used for testing)
	if Misc_IsCommandLineOptionSet("mode") and Misc_GetCommandLineString("mode") then 
		_skirmish.mode = Misc_GetCommandLineString("mode")
		if _skirmish.mode == "vp" then 
			_skirmish.mode = "victory_point"
		end
	end

	-- Autoresolve override
	if Misc_IsDevMode() and Misc_IsCommandLineOptionSet("autoresolve") and tonumber(Misc_GetCommandLineString("autoresolve")) ~= nil then
		_skirmish.autoresolve = math.min(1.0, math.max(0.01, tonumber(Misc_GetCommandLineString("autoresolve"))))
	end

	-- Campaign data
	local campaign = Game_RetrieveTableData(campaign_data_key, false)
	if campaign then
		if campaign.mission_data then 
			_skirmish.player_attacking = campaign.mission_data.attacker_race == campaign.mission_data.player_race_override
			if not _skirmish.mode and campaign.mission_data.mode then 
				_skirmish.mode = campaign.mission_data.mode
			end

			if not _skirmish.autoresolve then
				if campaign.mission_data.auto_resolve then
					local player_score = campaign.mission_data.auto_resolve.defender.total
					local enemy_score = campaign.mission_data.auto_resolve.attacker.total
					if _skirmish.player_attacking then
						player_score = campaign.mission_data.auto_resolve.attacker.total
						enemy_score = campaign.mission_data.auto_resolve.defender.total
					end
					print(string.format("Skirmish_OnInit() - enemy score  = %.0f, player score = %.0f", enemy_score, player_score))
					enemy_score = math.max(1, enemy_score)
					player_score = math.max(1, player_score)
					_skirmish.autoresolve = 1 - player_score / (enemy_score + player_score)
				end
			end
		end
	end
	_skirmish.autoresolve = _skirmish.autoresolve or 0.5

	Skirmish_InitPlayers()
	Skirmish_InitCamera()
	UI_SetMinimapTrueNorth(World_GetRand(1,360))		--TODO: Set orienatation to match campaign

	print(string.format("Skirmish_OnInit() - autoresolve = %.02f", _skirmish.autoresolve))
	print(string.format("Skirmish_OnInit() - enemy company = %s, player company = %s", _skirmish.company.enemy, _skirmish.company.player))

	if _skirmish.player_attacking then
		
		print("Skirmish_OnInit() - "..Loc_ToAnsi(Player_GetDisplayName(local_player)).." attacking")

		-- If win condition not specified by mission data or command arg, then use the next one in sequence
		if not _skirmish.mode or (_skirmish.mode ~= "rescue" and not Table_Contains(modes.player_attacking, _skirmish.mode)) then
			if campaign then
				local skirmish_attacks = (campaign.skirmish_attacks or 0) + 1
				deferred_campaign_data.skirmish_attacks = skirmish_attacks
				_skirmish.mode = modes.player_attacking[((skirmish_attacks - 1) % #modes.player_attacking) + 1]
				_skirmish.battles = skirmish_attacks + (campaign.skirmish_defenses or 0)
			else	-- pick one at random
				_skirmish.mode = modes.player_attacking[World_GetRand(1, #modes.player_attacking)]
			end
		end

		print("Skirmish_OnInit() - using ".._skirmish.mode.." mode")

		if _skirmish.mode == "territory" then
			Skirmish_InitMaxTickets(300)
			Skirmish_InitStartingTerritory(1, enemy_player)
			Skirmish_InitStartingUnits(3)
			Skirmish_InitModeTerritory()
		elseif _skirmish.mode == "rout" then
			Skirmish_InitMaxTickets(300)
			Skirmish_InitStartingTerritory(1, enemy_player)
			Skirmish_InitStartingUnits(3)
			Skirmish_InitModeRout()
		elseif _skirmish.mode == "cutoff" then
			Skirmish_InitStartingTerritory(1, enemy_player)
			Skirmish_InitStartingTerritory(Scale({2,2,1,1,1}), local_player)
			Skirmish_InitStartingUnits(3)
			Skirmish_InitModeCutoff(local_player, _skirmish.narrative.attack_cutoff)
		elseif _skirmish.mode == "knockout" then
			Skirmish_InitMaxTickets(250)
			Skirmish_InitStartingTerritory(1, enemy_player)
			Skirmish_InitStartingUnits(3)
			Skirmish_InitModeKnockout()
		elseif _skirmish.mode == "rescue" then
			Skirmish_InitStartingTerritory(Scale({1,1,1,2}), enemy_player)
			Skirmish_InitStartingUnits(3)
			Skirmish_InitModeRescue()
		elseif _skirmish.mode == "fixed_force" then
			Skirmish_InitStartingUnits(1)
			Skirmish_InitModeFixedForceAttack(local_player, enemy_player, _skirmish.narrative.attack_fixed)
		end

	else	-- Player defending
		
		print("Skirmish_OnInit() - "..Loc_ToAnsi(Player_GetDisplayName(local_player)).." defending")
		
		-- If win condition not specified by mission data or command arg, then use the next one in sequence
		if not _skirmish.mode or not Table_Contains(modes.player_defending, _skirmish.mode) then 
			if campaign then
				local skirmish_defenses = (campaign.skirmish_defenses or 0) + 1
				deferred_campaign_data.skirmish_defenses = skirmish_defenses
				_skirmish.mode = modes.player_defending[((skirmish_defenses - 1) % #modes.player_defending) + 1]
				_skirmish.battles = skirmish_defenses + (campaign.skirmish_attacks or 0)
			else	-- pick one at random
				_skirmish.mode = modes.player_defending[World_GetRand(1, #modes.player_defending)]
			end
		end

		print("Skirmish_OnInit() - using ".._skirmish.mode.." mode")

		if _skirmish.mode == "victory_point" or _skirmish.mode == "vp" then
			Skirmish_InitMaxTickets(300)
			Skirmish_InitStartingTerritory(1, local_player)
			Skirmish_InitStartingUnits(3)
			Skirmish_InitModeDefendVP()
		elseif _skirmish.mode == "cutoff" then
			Skirmish_InitStartingTerritory(Scale({2,2,1,1,1}), local_player)
			Skirmish_InitStartingUnits(3)
			Skirmish_InitModeCutoff(enemy_player, _skirmish.narrative.defend_cutoff)
		elseif _skirmish.mode == "fixed_force" then
			Skirmish_InitStartingUnits(1)
			Skirmish_InitModeFixedForceDefense(enemy_player, local_player, _skirmish.narrative.defend_fixed)
		end
	end

	if _skirmish.mode ~= "fixed_force" then
		--Rule_AddOneShot(Skirmish_InitArtillery, 10, { artillery = World_GetRand(-2, 2) }, mission_rule)
		Skirmish_InitBonusObjective()

		-- Progressively increase enemy popcap over time
		_skirmish.enemy_popcap = 0
		local popcap = { 	-- time-popcap pairs
			{19*60, Scale({60, 64, 68, 72, 76, 84, 92, 100, 140})},
			{16*60, Scale({52, 56, 60, 64, 68, 72, 84, 100, 140})},
			{13*60, Scale({48, 52, 56, 60, 64, 68, 72, 76, 140})},
			{10*60, Scale({40, 44, 48, 52, 60, 64, 68, 72, 140})},
			{ 7*60, Scale({30, 36, 40, 44, 48, 56, 60, 64, 140})},
			{ 4*60, Scale({22, 24, 26, 30, 32, 34, 36, 48, 140})},
			{ 2*60, Scale({18, 18, 20, 22, 24, 26, 28, 36, 140})},
			{  0*0, Scale({12, 12, 14, 18, 20, 22, 24, 36, 140})},
		}
		Rule_AddInterval(Skirmish_SetEnemyPopCap, 5, popcap, mission_rule)

		-- Increase enemy manpower income based on autoresolve score
		local manpower_income_bonus = math.max(0, 500 * (_skirmish.autoresolve - 0.5) + 20)
		if manpower_income_bonus > 0 then
			print(string.format("Skirmish_OnInit() - enemy manpower income increased by %.0f/min", manpower_income_bonus))
			Modify_PlayerResourceRate(enemy_player, RT_Manpower, manpower_income_bonus / 60 / Game_GetSimRate(), MUT_Addition)
		end

		Rule_AddOneShot(Skirmish_SpawnReinforcements, 25.0, nil, mission_rule)
	end

	Affectors_Log(campaign)

	-- Deter base rush
	local eg_hq = Player_GetEntities(enemy_player)
	for i = 1, EGroup_CountSpawned(eg_hq) do
		local entity = EGroup_GetSpawnedEntityAt(eg_hq, i)
		if Entity_IsOfType(entity, "annihilation_condition") then
			Rule_AddEntityEvent(Skirmish_EnemyHQDamaged, entity, GE_DamageReceived)
		end
	end

	-- Partisan loot supplies
	local caches = 2
	if Misc_IsCommandLineOptionSet("caches") and tonumber(Misc_GetCommandLineString("caches")) ~= nil then
		caches = math.max(1, math.min(99, tonumber(Misc_GetCommandLineString("caches"))))
	end
	Affectors_StartPartisanSupplies(Table_GetRand(Skirmish_GetMarkers("mkr_cache", local_player, true), caches))
end


-- Override Project_Prestart() in anvil.scar so that fade in can be delayed until after base buildings are spawned.
function Project_PreStart()
	Affectors_UseAffectors()
end


-- Called by OnInit() in core.scar on mission start.
function Skirmish_Start()
	
	-- Delay base construction so HQ attachments have time to finsish spawning
	if _skirmish.mode == "rescue" then
		Skirmish_InitStartingBuildings(1)
	elseif _skirmish.mode ~= "fixed_force" then
		-- Increase starting building tier as player advances through campaign
		Skirmish_InitStartingBuildings(math.min(3, math.ceil((_skirmish.battles or 1) / 4)))
	end
	
	Core_CallDelegateFunctions("ShowUI", true)
	if primary then 
		Objective_Start(primary, primary.showTitle or false, true)
	end

	Skirmish_InitEnemyDefenses()
	
	Game_FadeToBlack(FADE_IN, 2)
end


-- Called by core.scar when save game is loaded.
-- Triggers display of scripted UI elements.
function Skirmish_OnGameRestore()
	Core_CallDelegateFunctions("ShowUI", true)
end

-- Called via Core_CallDelegateFunctions("OnTicketsChanged") signalling ticket count has changed.
-- Triggers an enemy counterstrike action of some sort.
function Skirmish_OnTicketsChanged(player, tickets, previous_tickets, silent)
	if tickets < 160 and player == enemy_player then
		Skirmish_Counterstrike(Skirmish_GetTargets(2, true, true))
	end
	
	-- Too late to start a bonus objective
	if tickets < 80 and not bonus then 
		TimeRule_PauseWithGroup(bonus_rule)
	end
end


-- Called when a win condition has been met signalling that the match is ready to end.
-- Clean up UI and rules associated with this script module and end the match.
function Skirmish_OnWinConditionTriggered(match_result)

	if win_condition_triggered then
		return
	end
	
	win_condition_triggered = true
	
	local _PrintPlayerData = function(outcome_type, player_indices)
		print(outcome_type)
		for i = 1, #player_indices do
			local player = World_GetPlayerAt(player_indices[i])
			print(string.format("    %s (player %d, %s)",
				Loc_ToAnsi(Player_GetDisplayName(player)),
				World_GetPlayerIndex(player),
				Player_GetRaceName(player)))
		end
	end

	-- Log match result
	print(string.format("Match ended. Duration: %s, Mode: %s, Bonus: %s, Win Reason: %d", 
		Loc_ToAnsi(Loc_FormatTime_H_M_S(World_GetGameTime(), false)),
		_skirmish.mode,
		_skirmish.bonus,
		match_result.win_reason))
	_PrintPlayerData("Winners:", match_result.winners)
	_PrintPlayerData("Losers:", match_result.losers)

	_skirmish.match_result = _skirmish.match_result or match_result

	-- Remove all mission rules 
	TimeRule_PauseWithGroup(mission_rule)
	TimeRule_PauseWithGroup(bonus_rule)
	EventRule_PauseAll()

	-- End of match music - disabled by audio, redundant currently
--	Core_CallDelegateFunctions("OnGameOver", match_result, true)

	-- Set everything invulnerable
	for i = 1, World_GetPlayerCount() do
		SGroup_SetInvulnerable(Player_GetSquads(World_GetPlayerAt(i)), true)
		EGroup_SetInvulnerable(Player_GetEntities(World_GetPlayerAt(i)), true)
	end

	UI_SetEnablePauseMenu(false)
	UI_ToggleDecorators()
	Misc_ClearSelection()
	Misc_SetDefaultCommandsEnabled(false)
	Misc_SetSelectionInputEnabled(false)

	-- Relay match result to campaign map
	local campaign = Game_RetrieveTableData(campaign_data_key, false)
	if campaign and campaign.mission_data then

		local metamap_victor = World_GetPlayerAt(2)
		local is_local_player_winner = Table_Contains(match_result.winners, World_GetPlayerIndex(Game_GetLocalPlayer()))
		if is_local_player_winner then
			-- Map the winner of the skirmish to the campaign meta-map (where human player is always index 1 and AI always index 2)
			metamap_victor = World_GetPlayerAt(1)

			-- Victory rewards
			Player_AddResource(Game_GetLocalPlayer(), RT_Requisition, 1)
		end
		
		if bonus and Objective_IsComplete(bonus) then
			Player_AddResource(Game_GetLocalPlayer(), RT_Requisition, 1)
		end

		local report = { 
			winning_player = metamap_victor,	-- PlayerID of the winner in the campaign meta-map
			is_local_player_winner = is_local_player_winner,
			gameLength = World_GetGameTime(),
			auto_resolved = false,
		}
		MetaMap_FinishRTS(report, deferred_campaign_data)
	end
end


-----------------------------------------------------------------------
-- Internal/private functions
-----------------------------------------------------------------------

-- Returns the given value rounded to the nearest integer.
-- Note: 0.5 is rounded up to 1 and -0.5 is rounded down to -1
function math.round(v)
	if v >= 0 then
		return math.floor(v + 0.5)
	end
	return math.ceil(v - 0.5)
end

-- Returns a value from a given range scaled to the autoresolve score. 
-- Works best with a table of 5 or 7 elements.
-- e.g. Scale({1,2,3,4,5}) or Scale(10,20,math.floor)
function Scale(v1, v2, f)
	if scartype(v1) == ST_TABLE then
		if #v1 == 1 then
			return v1[1]
		else
			return v1[math.min(#v1, Scale(1, #v1, math.round))]
		end
	elseif scartype(v1) == ST_NUMBER and scartype(v2) == ST_NUMBER then
		local result = v1 + (v2 - v1) * _skirmish.autoresolve
		if scartype(f) == ST_FUNCTION then
			result = f(result)
		end
		return result
	end
end

-- Version of Table_GetRandomItem() that always returns a table.
function Table_GetRand(t, num)
	local result = {}
	if num == nil or num == 1 then
		table.insert(result, t[World_GetRand(1, #t)])
	elseif num > 1 then
		num = math.min(num, #t)
		local indexes = {}
		for i = 1, #t do
			indexes[i] = i
		end
		for i = 1, num do
			local r = World_GetRand(1, #indexes)
			table.insert(result, t[indexes[r]])
			table.remove(indexes, r)
		end
	end
	return result
end


-- Rule that slowly increases enemy player's popcap over time.
function Skirmish_SetEnemyPopCap(context, data)
	local time = World_GetGameTime()
	local pop_scale = Util_DifVar({1.5, 1.25, 1.2, 1})
	if time > Util_DifVar({300, 300, 120, 0}) then
		pop_scale = Util_DifVar({1.3, 1.15, 1, 0.8})
	end
	local player_population = Player_GetCurrentPopulation(local_player, CT_Personnel)
	for i,v in ipairs(data) do
		if time >= v[1] or player_population >= pop_scale * v[2] then
			if _skirmish.enemy_popcap ~= v[2] then
				_skirmish.enemy_popcap = v[2]
				Player_SetPopCapOverride(enemy_player, _skirmish.enemy_popcap)
				print("Skirmish_SetEnemyPopCap() - ".._skirmish.enemy_popcap.." at "..math.floor(v[1]/60).." minutes")
				if i == 1 then 
					Rule_RemoveMe()
				end
			end
			break
		end
	end
end


-- Returns the company type for a given player.
-- (Reverse engineering of Dev_GrantCompanyAbilities() and Dev_ModifyEnemyPlayers())
function Skirmish_GetCompanyType(player)
	if Player_GetRace(player) == RACE.GERMANS then
		if Misc_IsCommandLineOptionSet("enemycompanytype") then
			return string.lower(Misc_GetCommandLineString("enemycompanytype"))
		else
			local campaign = Game_RetrieveTableData(campaign_data_key, false)
			if campaign and campaign.mission_affectors then
				return campaign.mission_affectors.enemy_company_bp_name
			else
				return Table_GetRandomItem({
						"company_armored_ger",
						"company_infantry_ger",
						"company_luftwaffe_ger",
						"company_mechanized_ger",
					})
			end
		end
	else
		if Misc_IsCommandLineOptionSet("companytype") then
			return string.lower(Misc_GetCommandLineString("companytype"))
		else
			local campaign = Game_RetrieveTableData(campaign_data_key, false)
			if campaign and campaign.mission_affectors and campaign.mission_affectors.player_company_bp_name then
				return campaign.mission_affectors.player_company_bp_name
			else
				local company_upgrades = {
					company_armoured_us = {"dev_unlock_all_core_abilities_armoured_us", "c_armoured_company_us"},
					company_paratrooper_us = {"dev_unlock_all_core_abilities_airborne_us", "airborne_company_us"},
					company_spec_ops_us = {"dev_unlock_all_core_abilities_special_operations_us", "c_special_operations_company_us"},
					company_airborne_uk = {"dev_unlock_all_core_armored_abilities_uk"},
					company_armoured_uk = {"dev_unlock_all_core_armored_abilities_uk"},
					company_artillery_uk = {"dev_unlock_all_core_artillery_abilities_uk"},
				}
				for company, upgrades in Table_DeterministicOrderedPairs(company_upgrades) do
					for _, upgrade in pairs(upgrades) do
						if Player_HasUpgrade(player, BP_GetUpgradeBlueprint(upgrade)) then
							return company
						end
					end
				end
			end
		end
	end
end

-- Applies common modifiers and upgrades to players  
function Skirmish_InitPlayers()

	local _DisableResourceIncome = function(player)
		Player_CompleteUpgrade(player, BP_GetUpgradeBlueprint("disable_passive_resource_income"))
		for resource_type = RT_Begin, RT_Count do
			Player_SetResource(player, resource_type, 0)
		end
	end

	Skirmish_InitStartingResources(local_player, 
		{ 
			0, -- action
			Scale({75, 50, 30, 15, 0}), -- fuel
			Scale({250, 200, 150, 100, 0}), -- manpower
			Scale({125, 100, 75, 40, 0}), -- munitions
		}
	)
	Skirmish_InitStartingResources(enemy_player, { 0, 0, 0, 0 })
	Skirmish_InitStartingResources(allied_player, { 0, 0, 0, 0 })
	Skirmish_InitStartingResources(unused_player, { 0, 0, 0, 0 })

	-- Delay enemy activity until intro VO and objective are delivered
	AI_Enable(enemy_player, false)
	if _skirmish.player_attacking then
		Rule_AddOneShot(Skirmish_EnableAI, Scale(25,0, math.floor))
	else
		Rule_AddOneShot(Skirmish_EnableAI, 4.0)
	end

	-- Disable AI for ally/unused players
	AI_Enable(allied_player, false)
	AI_Enable(unused_player, false)

	-- Increase visibility of any allied squads
	UI_SetSquadDecoratorsAlwaysVisibleForPlayer(allied_player, true)

	-- Give local player an income boost
	Anvil_SetPlayerResources(local_player, 280, 15, 5, 9999, 9999, 9999)

	_DisableResourceIncome(allied_player)
	_DisableResourceIncome(unused_player)

	Dev_GrantCompanyAbilities(local_player)
	Dev_ModifyEnemyPlayers()

	-- Cache company type
	_skirmish.company.player = Skirmish_GetCompanyType(local_player)
	_skirmish.company.enemy = Skirmish_GetCompanyType(enemy_player)

	-- Set skirmish personality based on company type
	local company_personality = {
		company_armored_ger = "armoured_personality.xml",
		company_infantry_ger = "infantry_personality.xml",
		company_luftwaffe_ger = "infantry_personality.xml",
		company_mechanized_ger = "mechanized_personality.xml",
	}
	AI_SetPersonality(enemy_player, company_personality[_skirmish.company.enemy] or "default_ai_personality.xml")
	AI_SetPersonality(unused_player, company_personality[_skirmish.company.enemy] or "default_ai_personality.xml")

	-- Reassign base defenses, remove default squads
	local _ReassignDefaultSquads = function(player1, player2)
		SGroup_ForEach(Player_GetSquads(player1), 
			function(sgroup, index, squad)
				if Squad_IsOfType(squad, "base_defense") then
					Squad_SetPlayerOwner(squad, player2)
				else
					Squad_DeSpawn(squad)
				end
			end)
	end
	_ReassignDefaultSquads(allied_player, local_player)
	_ReassignDefaultSquads(unused_player, enemy_player)

	-- Remove default entities (HQ)
	local _ReassignDefaultEntities = function(player1, player2)
		EGroup_ForEach(Player_GetEntities(player1), 
			function(egroup, index, entity)
				local bp_name = BP_GetName(Entity_GetBlueprint(entity))
				if not (string.find(bp_name, "starting_") or string.find(bp_name, "map_entry")) then
					Entity_DeSpawn(entity)
				else
					Entity_SetPlayerOwner(entity, player2)
				end
			end)
	end
	_ReassignDefaultEntities(allied_player, local_player)
	_ReassignDefaultEntities(unused_player, enemy_player)

	-- Remove battlegroup upgrades  // UI ignores this anyway (BUG #100181)
	for _, techtree in pairs(BP_GetTechTreeBlueprintsByType("battlegroup")) do
		local techtree_info = BP_GetTechTreeBPInfo(techtree)
		Player_SetUpgradeAvailability(Game_GetLocalPlayer(), techtree_info.activation_upgrade, ITEM_REMOVED, Loc_Empty() )
	end
end


-- Set the default camera to face the middle of the map
function Skirmish_InitCamera()
	local start = Player_GetStartingPosition(Game_GetLocalPlayer())
	local direction = Util_GetDirectionFromAtoB(start, Util_ScarPos(0,0))
	local focus = World_GetOffsetPosition(start, direction, OFFSET_FRONT, 5)
	local angle = math.deg(math.atan(direction.z, direction.x))
	Camera_SetDefaultOrbit(270 - angle)
	Camera_ResetToDefault()
	Camera_MoveTo(focus, nil, nil, nil, true)
end


-- Adds defenses (only mines currently) to discourage base rush
function Skirmish_InitEnemyDefenses()
	local markers_mines = Skirmish_GetMarkers("mkr_mine", enemy_player, true)
	local markers_to_mine = Table_GetRand(markers_mines, Scale({0,1,2,3,4}))
	for _, marker in pairs(markers_to_mine) do
		local pos = Prox_GetRandomPosition(Marker_GetPosition(marker), 7, 2)
		local mine = Entity_Create(EBP.GERMAN.MINE_PIONEER_GER,  enemy_player, pos, true)
		Entity_WarpToPos(mine, World_GetSpawnablePosition(pos, mine))
		Entity_Spawn(mine)
		Entity_ForceConstruct(mine)
	end
end


function Skirmish_InitStartingBuildings(tier)

	-- Triage Center spawns medics so use a building with similar footprint instead
	local medical_ebps = {
		americans = EBP.AMERICAN.WEAPON_SUPPORT_CENTER_US,
		british = EBP.AMERICAN.WEAPON_SUPPORT_CENTER_US,
	}
	
	local _SpawnBase = function(player, ebps)
		local eg_all = Player_GetEntities(player)
		local eg_hq = EGroup_CreateUnique()
		EGroup_Filter(eg_all, "hq", FILTER_REMOVE, eg_hq)
		local start = Player_GetStartingPosition(player)
		local facing = Util_GetDirectionFromAtoB(start, Util_ScarPos(0,0))
		if EGroup_Count(eg_hq) > 0 then 
			facing = Entity_GetHeading(EGroup_GetEntityAt(eg_hq, 1))
		end
		-- Reserve space for triage center (~same size as weapon_support_center_us)
		local medical_building
		local medical_ebp = medical_ebps[Player_GetRaceName(player)]
		if scartype(medical_ebp) == ST_PBG then
			local pos = World_GetOffsetPosition(start, facing, OFFSET_FRONT, World_GetRand(15,17))
			pos = World_GetOffsetPosition(pos, facing, OFFSET_LEFT, World_GetRand(-5,5)/2)  -- Add some left/right variability
			local facing_pos = World_GetOffsetPosition(pos, facing, OFFSET_FRONT, 12)
			medical_building = Entity_CreateFacing(medical_ebp, allied_player, pos, facing_pos, true)
			Entity_Spawn(medical_building)
			Entity_ForceConstruct(medical_building)
		end
		--start = World_GetOffsetPosition(start, facing, OFFSET_FRONT, 12)	-- prefer building in front of HQ
		for _, ebp in pairs(Table_Shuffle(ebps)) do
			if EBP_IsOfRace(BP_GetName(ebp), Player_GetRace(player)) and not EGroup_ContainsBlueprints(eg_all, ebp, ANY) then
				World_UpdatePathfindingBlockers()
				local pos = Entity_FindConstructionLocation(player, ebp, start, 80, 1)
				local facing_pos = World_GetOffsetPosition(pos, facing, OFFSET_FRONT, 10)
				local entity = Entity_CreateFacing(ebp, player, pos, facing_pos, true)
				Entity_Spawn(entity)
				Entity_ForceConstruct(entity)
			end 
		end
		EGroup_Destroy(eg_hq)
		if scartype(medical_building) == ST_ENTITY then
			Entity_DeSpawn(medical_building)
		end
	end

	local unit_types_by_tier = {
		{"tier_1"},
		{"tier_2"},
		{"tier_3"},
		{"tier_4"},
	}

	-- Override starting tier if command line option provided
	if Misc_IsCommandLineOptionSet("tier") and tonumber(Misc_GetCommandLineString("tier")) ~= nil then
		tier = tonumber(Misc_GetCommandLineString("tier"))
	end
	tier = math.max(0, math.min(tier, 4))

	local types = {}
	for i = 1, tier do
		for _, unit_type in pairs(unit_types_by_tier[i]) do 
			table.insert(types, unit_type)
		end
	end
	local all_ebps = BP_GetEntityBlueprintsWithType(types)
	local ebps = {}
	for _, ebp in pairs(all_ebps) do
		table.insert(ebps, ebp)
	end

	_SpawnBase(local_player, ebps)
	_SpawnBase(enemy_player, ebps)

	-- Balance enemy upgrades
	if tier >= 1 then
		Player_CompleteUpgrade(enemy_player, BP_GetUpgradeBlueprint("medical_station_hq_ger"))
	end
	if tier >= 3 then
		Player_CompleteUpgrade(enemy_player, BP_GetUpgradeBlueprint("adv_mech_assault_tactics_ger"))
	end
	Player_SetUpgradeAvailability(enemy_player, BP_GetUpgradeBlueprint("luftwaffe_kompanie_vet_ger"), ITEM_REMOVED)
	Player_SetUpgradeAvailability(enemy_player, BP_GetUpgradeBlueprint("infanterie_kompanie_vet_ger"), ITEM_REMOVED)
	Player_SetUpgradeAvailability(enemy_player, BP_GetUpgradeBlueprint("panzergrenadier_kompanie_vet_ger"), ITEM_REMOVED)
end


-- Sets (or boosts) the player's starting resource amount {action, fuel, manpower, munitions}
function Skirmish_InitStartingResources(player, amount, set)
	if set then
		Player_SetResource(player, RT_Manpower, amount[RT_Manpower])
		Player_SetResource(player, RT_Fuel, amount[RT_Fuel])
		Player_SetResource(player, RT_Munition, amount[RT_Munition])
	else -- add to current resource amount
		Player_SetResource(player, RT_Manpower, Player_GetResource(player, RT_Manpower) + amount[RT_Manpower])
		Player_SetResource(player, RT_Fuel, Player_GetResource(player, RT_Fuel) + amount[RT_Fuel])
		Player_SetResource(player, RT_Munition, Player_GetResource(player, RT_Munition) + amount[RT_Munition])
	end
	
	if player == Game_GetLocalPlayer() then
		Player_AddUnspentCommandPoints(player, Scale({4,3,2,1,0}))
	end
end

function Skirmish_InitStartingUnits(units_override)

	local _SwapUnits = function(player, sbp, sbp_replacement, upgrade)
		SGroup_ForEach(Player_GetSquads(player), function(sgroup, index, squad)
				if Squad_GetBlueprint(squad) == sbp then
					if not upgrade or Player_HasUpgrade(player, upgrade) then
						local pos = Squad_GetPosition(squad)
						Squad_DeSpawn(squad)
						if sbp_replacement then
							Util_CreateSquads(player, nil, sbp_replacement, pos, pos, nil, nil, false, nil, upgrades, Util_ScarPos(0,0))
						end
					end
				end
			end)
	end
	
	
	local _SpawnUnits = function(player, units)
		local squads = {}
		if units == 2 then
			table.insert(squads, default_unit_sbp[Player_GetRaceName(player)])
		else
			for j = 3, units do
				table.insert(squads, basic_infantry_sbp[Player_GetRaceName(player)])
			end
		end
		for j = 1, #squads do
			local pos = World_GetOffsetPositionRelativeToFacingTarget(Player_GetStartingPosition(player), Util_ScarPos(0,0), 15.0)
			Squad_CreateAndSpawnToward(squads[j], player, 0, pos, Util_ScarPos(0,0))
		end
	end

	local units = 1
	if units_override then 
		units = units_override
	end

	if units > 1 then
		_SpawnUnits(local_player, units)
		_SpawnUnits(enemy_player, units)
	end

	_SwapUnits(local_player, SBP.AMERICAN.SCOUT_US, SBP.AMERICAN.ASSAULT_ENGINEER_US, BP_GetUpgradeBlueprint("c_armoured_company_us"))
	_SwapUnits(local_player, SBP.AMERICAN.SCOUT_US, SBP.AMERICAN.PATHFINDER_US, BP_GetUpgradeBlueprint("airborne_company_us"))
	_SwapUnits(local_player, SBP.AMERICAN.CAPTAIN_US)		-- Remove captain squad spawned by infantry support center HQ upgrade
end



-- Rule that calls in off-map reinforcements based on mission affectors
function Skirmish_SpawnReinforcements(context, data)
	if data then 
		Affectors_SpawnReinforcements(data.player, data.start, data.destination, data.silent)
	else
		Affectors_SpawnReinforcements(local_player)
		Affectors_SpawnReinforcements(enemy_player)
	end
end


-- Delays enabling of AI opponent until after objective pops are complete
function Skirmish_EnableAI(context)
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_EnableAI, 4.0)
	else
		AI_Enable(enemy_player, true)
	end
end

-- Sets territory ownership. 1  = base + adjacent sector, 2 = half the map.
-- If owner is nil then territory ownership is done for both players.
function Skirmish_InitStartingTerritory(territory, owner)
	territory = territory or 0
	local exclusions = Scale({
			{ "starting_territory_team", "medium", "high" },
			{ "starting_territory_team", "high" },
			{ "starting_territory_team" },
			{ "starting_territory_team" },
		})

	-- Exclude medium/high resource points and base sectors
	local _IsValidPoint = function(entity)
		local ebp_name = BP_GetName(Entity_GetBlueprint(entity))
		
		for _, excluded in pairs(exclusions) do
			if string.find(ebp_name, excluded) then 
				return false
			end
		end
		return true
	end

	if territory == 1 then
		
		-- Give each player control of resource points adjacent to their base
		local _CaptureAdjacentTerritory = function(player)
			local eg_sectors = EGroup_CreateUnique()
			local sectors = Territory_GetAdjacentSectors(Territory_FindClosestSectorToPoint(Player_GetStartingPosition(player)))
			for j = 1, #sectors do 
				local entity = Territory_GetSectorCreatorEntity(sectors[j])
				if _IsValidPoint(entity) then 
					EGroup_Add(eg_sectors, entity)
				end
			end
			EGroup_InstantCaptureStrategicPoint(eg_sectors, player)
			FOW_RevealEGroupOnly(eg_sectors, 0.5)-- Make visible briefly so player can see they are captured
			EGroup_Destroy(eg_sectors)
		end
		
		if owner then
			_CaptureAdjacentTerritory(owner)
		else
			_CaptureAdjacentTerritory(local_player)
			_CaptureAdjacentTerritory(enemy_player)
		end

	elseif territory == 2 then
		-- Even split between players 
		local threshold = 15	-- Point must be at least this much closer to player's start than enemy's start in order to take ownership
		local eg_points = EGroup_CreateUnique()
		World_GetStrategyPoints(eg_points, false)
		EGroup_ForEach(eg_points,
			function (egroup, index, entity)
				local pos = Entity_GetPosition(entity)
				local d_local =  World_DistancePointToPoint(pos, Player_GetStartingPosition(local_player))
				local d_enemy =  World_DistancePointToPoint(pos, Player_GetStartingPosition(enemy_player))
				if math.abs(d_local - d_enemy) > threshold then
					local nearest_player = local_player
					if d_enemy < d_local then
						nearest_player = enemy_player
					end
					if owner then
						if owner == nearest_player then
							Entity_InstantCaptureStrategicPoint(entity, nearest_player)
						end
					else
						Entity_InstantCaptureStrategicPoint(entity, nearest_player)
					end
				end
			end)
		FOW_RevealEGroupOnly(eg_points, 1.0)	-- Make visible briefly so player can see they are captured
		EGroup_Destroy(eg_points)
	end
end



function Skirmish_InitMaxTickets(max_tickets, weight_by_autoresolve)

	-- Override max ticket count if command line option provided
	if Misc_IsCommandLineOptionSet("tickets") then
		local ticket_override = tonumber(Misc_GetCommandLineString("tickets"))
		if ticket_override ~= nil and ticket_override > 0 then
			max_tickets = ticket_override
		end
	end

	-- Weight either max ticket count by weight_by_autoresolve
	local local_player_tickets = math.min(math.floor((0.4 + 0.6 * (1-_skirmish.autoresolve)*2) * max_tickets), max_tickets)
	local enemy_player_tickets = math.min(math.floor((0.4 + 0.6 * _skirmish.autoresolve*2) * max_tickets), max_tickets)
	if weight_by_autoresolve then
		Core_CallDelegateFunctions("OnMaxTicketsChanged", local_player_tickets, local_player)
		Core_CallDelegateFunctions("OnMaxTicketsChanged", enemy_player_tickets, enemy_player)
	else
		Core_CallDelegateFunctions("OnMaxTicketsChanged", max_tickets)
	end	
	Core_CallDelegateFunctions("OnTicketsChanged", local_player, local_player_tickets)
	Core_CallDelegateFunctions("OnTicketsChanged", enemy_player, enemy_player_tickets)
end


function Skirmish_InitMinefields()

	local SpawnWarningSigns = function(near, radius_min, radius_max, count)
		count = math.min(count, 3)
		local offsets = {OFFSET_FRONT}
		local signs = {BP_GetEntityBlueprint("mine_field_sign_01"), BP_GetEntityBlueprint("mine_field_sign_02")}
		if count == 2 then
			table.insert(offsets, Table_GetRandomItem({OFFSET_BACK_RIGHT, OFFSET_BACK_LEFT, OFFSET_BACK}))
		elseif count >= 3 then
			offsets = {OFFSET_FRONT_LEFT, OFFSET_FRONT_RIGHT, OFFSET_BACK}
		end
		local ref_pos = Prox_GetRandomPosition(near, 2, 2)
		for i = 1, count do
			local pos = World_GetOffsetPosition(near, Util_GetDirectionFromAtoB(near, ref_pos), offsets[i], World_GetRand(radius_min, radius_max))
			local facing = World_GetOffsetPosition(near, Util_GetDirectionFromAtoB(near, pos), OFFSET_FRONT, radius_max + 2)
			Entity_Spawn(Entity_CreateENVFacing(signs[World_GetRand(1,2)], pos, facing, true))
		end
	end
	
	local mine_count = 0
	local points = {}
	local start_pos =  Player_GetStartingPosition(local_player)
	local offsets = {OFFSET_FRONT, OFFSET_RIGHT, OFFSET_LEFT, OFFSET_FRONT_LEFT, OFFSET_FRONT_RIGHT}
	local eg_points = EGroup_CreateUnique()
	World_GetStrategyPoints(eg_points, true)
	EGroup_ForEach(eg_points,
		function(egroup, i, entity)
			if Entity_IsSpawned(entity) and World_DistancePointToPoint(Entity_GetPosition(entity), start_pos) > 100 then
				table.insert(points, Entity_GetPosition(entity))
			end
		end)
	points = Table_GetRand(points, math.max(7, math.ceil(Scale(0.5, 0.7) * #points)))
	for i = 1, #points do
		local point = points[i]
		local facing = Util_GetDirectionFromAtoB(point, start_pos)
		local max_mines = World_GetRand(Scale({2,2,2,3,3}), Scale({2,3,3,3,4}))
		for j = 1, max_mines do
			local pos = Prox_GetRandomPosition(World_GetOffsetPosition(point, facing, offsets[j], 14), 6, 1)
			local mine = Entity_Create(EBP.GERMAN.MINE_PIONEER_GER,  enemy_player, pos, true)
			Entity_WarpToPos(mine, World_GetSpawnablePosition(pos, mine))
			Entity_Spawn(mine)
			Entity_ForceConstruct(mine)
			mine_count = mine_count + 1
		end
		Table_Shuffle(offsets)
		SpawnWarningSigns(point, 13, 16, World_GetRand(2, 3))
	end
	EGroup_Destroy(eg_points)

	--Teller mines
	local mkr_tellers = {}
	local n = 1
	while Marker_Exists("mkr_teller_"..n, "") do
		table.insert(mkr_tellers, Marker_FromName("mkr_teller_"..n, ""))
		n = n + 1
	end
	local teller_count = 0
	local mine_freq = Scale({10, 20, 30, 40, 50})
	for i = 1, #mkr_tellers do
		if World_GetRand(1,100) <= mine_freq
			and World_DistancePointToPoint(Player_GetStartingPosition(local_player), Marker_GetPosition(mkr_tellers[i])) > 100 then
			local pos = Prox_GetRandomPosition(Marker_GetPosition(mkr_tellers[i]), 4, 1)
			local mine = Entity_Create(EBP.GERMAN.MINE_TELLER_GER, enemy_player, pos, true)
			Entity_WarpToPos(mine, World_GetSpawnablePosition(pos, mine))
			Entity_Spawn(mine)
			Entity_ForceConstruct(mine)
			teller_count = teller_count + 1
			if World_GetRand(1,100)/100 > _skirmish.autoresolve then
				SpawnWarningSigns(pos, 6, 9, World_GetRand(1, 2))
			end
		end
	end
	print(string.format("Skirmish_InitMinefields() - created %d mines (%d teller)", mine_count + teller_count, teller_count))
end	


function Skirmish_InitArtillery(context, data)
	
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_InitArtillery, 10, data, mission_rule)
		return
	end
	
	local artillery = 0
	
	-- Override artillery setting if '-artillery' command line argument if provided.
	if Misc_IsCommandLineOptionSet("artillery") and tonumber(Misc_GetCommandLineString("artillery")) then
		artillery = math.min(tonumber(Misc_GetCommandLineString("artillery")), 5)
	elseif data and data.artillery then 
		artillery = math.max(0, data.artillery)
	end
	
	if artillery > 0 then 
		-- Create target list
		local targets = {}
		EGroup_ForEach(_skirmish.victory_points, function(egroup, i, entity)
				table.insert(targets, Entity_GetPosition(entity))
			end)
		if #targets == 0 then
			local eg = EGroup_CreateUnique()
			World_GetStrategyPoints(eg, false)
			EGroup_ForEach(eg, function(egroup, i, entity)
				table.insert(targets, Entity_GetPosition(entity))
				-- Increase chance of striking middle of map
				--if math.abs(pos.x) < World_GetWidth()/4 and math.abs(pos.z) < World_GetLength()/4 then
					--table.insert(targets, pos)
				--end
			end)
			EGroup_Destroy(eg)
		end
		
		-- Exclude base sectors
		local excluded_sectors = {}
		table.insert(excluded_sectors, Territory_FindClosestSectorToPoint(Player_GetStartingPosition(local_player)))
		table.insert(excluded_sectors, Territory_FindClosestSectorToPoint(Player_GetStartingPosition(enemy_player)))
		
		local artillery_data
		if artillery == 1 then 		-- sporadic_ineffective 
			artillery_data = { min_interval = 4, max_interval = 15, targets = targets, exclusions = excluded_sectors, avoid_player = true }
		elseif artillery == 2 then	--intense_ineffective 
			artillery_data = { min_interval = 2, max_interval = 10, targets = targets, exclusions = excluded_sectors, avoid_player = true }
		elseif artillery == 3 then	-- sporadic
			artillery_data = { min_interval = 4, max_interval = 15, targets = targets, exclusions = excluded_sectors }
		elseif artillery == 4 then	-- intense 
			artillery_data = { min_interval = 2, max_interval = 10, targets = targets, exclusions = excluded_sectors }
		elseif artillery == 5 then	-- insane
			artillery_data = { min_interval = 2, max_interval = 6, targets = targets, exclusions = excluded_sectors }
		end
		Rule_AddOneShot(Skirmish_DoArtilleryStrike, 10, artillery_data, mission_rule)
	end
end

	
function Skirmish_DoArtilleryStrike(context, data)
	
	Skirmish_AddPlayerAbilityIfNotExists(enemy_player, ABILITY.GERMAN.M_SINGLE_SHOT_ARTILLERY_GER)

	if #data.targets > 0 then 
		local attempts = 0
		local target_pos
		local max_range = data.max_range or 40
		local min_range = data.min_range or 6
		local is_valid_target_pos
		local sg = SGroup_CreateIfNotFound("sg_strike_zone")
		repeat
			attempts = attempts + 1
			is_valid_target_pos = true
			target_pos = Prox_GetRandomPosition(data.targets[World_GetRand(1, #data.targets)], max_range, min_range)
			
			for i = 1, #data.exclusions do
				is_valid_target_pos = is_valid_target_pos and Territory_GetSectorContainingPoint(target_pos) ~= data.exclusions[i]
			end
			
			if is_valid_target_pos and data.avoid_player then
				Player_GetAllSquadsNearMarker(local_player, sg, target_pos, 6)
				is_valid_target_pos = (SGroup_CountSpawned(sg) == 0)
			end
		until attempts > 20 or (is_valid_target_pos and (Player_CanSeePosition(local_player, target_pos) or Player_CanSeePosition(enemy_player, target_pos)))
		
		if is_valid_target_pos then
			Cmd_Ability(enemy_player, ABILITY.GERMAN.M_SINGLE_SHOT_ARTILLERY_GER, target_pos, nil, true)
		end
		Rule_AddOneShot(Skirmish_DoArtilleryStrike, World_GetRand(data.min_interval, data.max_interval), data, mission_rule)
	end
end



-- Creates an AI prefab at each VP owned by the player  
function Skirmish_PushVictoryPoints()
	
	-- Creates an AI prefab at given position. Valid behaviours are: "Hold", "Defend", "Push" 
	local _AI_Push = function(id, position, behaviour, min_squads, max_squads, radius)
		local name = behaviour.."_"..tostring(id)	
		for prefab_name, prefab_id in Table_DeterministicOrderedPairs(_skirmish.prefabs) do
			if prefab_name == name then 
				return
			end
		end 
		local player = Player_FindFirstEnemyPlayer(Game_GetLocalPlayer())	
		local prefab_id = AI_AddPrefab(player, name , behaviour, radius or 25, min_squads or 1, max_squads or 2, true, true)
		AI_SetPrefabTarget_Position(prefab_id, player, position)
		_skirmish.prefabs[name] = prefab_id
	end
	
	EGroup_ForEach(_skirmish.victory_points, function(egroup, i, entity)
			if not World_OwnsEntity(entity) and Entity_GetPlayerOwner(entity) == Game_GetLocalPlayer() then
				_AI_Push(Entity_GetID(entity), Entity_GetPosition(entity), "Push", 1, 3)
			end
		end)
end

function ShowCampaignBattleAfterActionReport()
	local win = Table_Contains(_skirmish.match_result.winners, World_GetPlayerIndex(Game_GetLocalPlayer())) 
	MetaMap_ShowAfterActionReport(win, "Skirmish_EndMatch")
end


function Skirmish_EndMatch()
	if Table_Contains(_skirmish.match_result.winners, World_GetPlayerIndex(local_player)) then
		World_SetPlayerAndAlliesWin(local_player, _skirmish.match_result.win_reason)
	else
		World_SetPlayerAndAlliesWin(enemy_player, _skirmish.match_result.win_reason)
	end
end


-- Objective callback used to test whether the win condition was triggered by the player.
function Skirmish_HasPlayerWon()
	if _skirmish.match_result then
		for i = 1, #_skirmish.match_result.winners do
			if Game_GetLocalPlayer() == World_GetPlayerAt(_skirmish.match_result.winners[i]) then
				return true
			end
		end
	end
end


-- Objective callback used to test whether the win condition was triggered by the AI.
function Skirmish_HasPlayerLost()
	if _skirmish.match_result then
		for i = 1, #_skirmish.match_result.losers do
			if Game_GetLocalPlayer() == World_GetPlayerAt(_skirmish.match_result.losers[i]) then
				return true
			end
		end
	end	
end

-- Fails bonus objective if incomplete on mission end.
function Skirmish_FailBonusObjective()		
	if bonus and not Objective_IsComplete(bonus) then
		Objective_Show(bonus, false, false)
		Objective_Fail(bonus, false, false)
	end	
end


function Skirmish_RemoveVictoryPoints()
	local positions = {}
	EGroup_ForEach(_skirmish.victory_points, function(egroup, i, entity)
			table.insert(positions, Entity_GetPosition(entity))
		end)
	EGroup_DestroyAllEntities(_skirmish.victory_points)

	-- Remove ghost image
	for _, position in pairs(positions) do
		FOW_RevealArea(position, 2.0, 0.5)	
	end
end

function Skirmish_RemoveTerritoryPoints()
	local positions = {}
	local eg = EGroup_CreateUnique()
	World_GetStrategyPoints(eg, false)
	EGroup_AddEGroup(eg, _skirmish.victory_points)
	EGroup_ForEach(eg, function(egroup, index, entity)
			if World_OwnsEntity(entity) then
				table.insert(positions, Entity_GetPosition(entity))
				Entity_Destroy(entity)
			end 
		end)
	EGroup_Destroy(eg)
	-- Remove ghost images
	for _, position in pairs(positions) do
		FOW_RevealArea(position, 2, 0.5)
	end
	UI_AllTerritoryHide()
end

-- Replaces all territory points with invisible territory points owned by owner
function Skirmish_HideTerritoryPoints(owner)
	local ebp = BP_GetEntityBlueprint("territory_creator_invisible")
	local positions = {}
	local eg = EGroup_CreateUnique()
	World_GetStrategyPoints(eg, false)
	EGroup_ForEach(eg, function(egroup, index, entity)
			table.insert(positions, Entity_GetPosition(entity))
			Entity_Destroy(entity)
		end)
	EGroup_Destroy(eg)
	
	-- Remove ghost images
	for _, position in pairs(positions) do
		FOW_RevealArea(position, 2, 0.5)
		local entity
		if owner then
			entity = Entity_CreateFacing(ebp, owner, position, Util_ScarPos(0,0), true)
		else
			entity = Entity_CreateENV(ebp, position, true)
		end
		Entity_Spawn(entity)
		Entity_ForceConstruct(entity)
	end
	UI_AllTerritoryHide()
end


-- Rule that updates territory ownership based on squads in it
function Skirmish_UpdateTerritory(context, data)
	local _GetSectors = function(eg)
		local sectors = {}
		EGroup_ForEach(eg, 
			function(egroup, index, entity)
				if Entity_IsPartOfSquad(entity) then
					local squad = Entity_GetSquad(entity)
					if Squad_IsRetreating(squad) 
						or Squad_IsOfType(squad, "airplane") 
						--or Squad_IsOfType(squad, "vehicle") 
						or Squad_IsOfType(squad, "building") then
						return
					end
					local sector = Territory_GetSectorContainingPoint(Entity_GetPosition(entity))
					if sector and not Table_Contains(sectors, sector) then
						table.insert(sectors, sector)
					end
				end
			end)
		return sectors
	end
	
	local _UpdateOwnership = function(sectors, exclude, player)
		local eg_sectors = EGroup_CreateUnique()
		for i = 1, #sectors do
			if not Table_Contains(exclude, sectors[i]) then
				local entity = Territory_GetSectorCreatorEntity(sectors[i])
				if entity then
					EGroup_Add(eg_sectors, entity)
				end
			end
		end
		EGroup_InstantCaptureStrategicPoint(eg_sectors, player)
		EGroup_Destroy(eg_sectors)
	end
	
	local allied_sectors = _GetSectors(Player_GetAllEntities(local_player))
	local enemy_sectors = _GetSectors(Player_GetAllEntities(enemy_player))
	_UpdateOwnership(allied_sectors, enemy_sectors, local_player)
	_UpdateOwnership(enemy_sectors, allied_sectors, enemy_player)
end


-----------------------------------------------------------------------
-- Win conditions
-----------------------------------------------------------------------

-- Basic victory point win condition but player must also maintain control of a key VP.
function Skirmish_InitModeDefendVP()

	Core_UnregisterModule("Territory")
	Core_UnregisterModule("EntityLoss")
	TicketUI_SetVisibility(true, true, false)
	
	AI_SetTable(enemy_player, "t_personality_tuning", "attack_unit_tags_multipliers", {
		capture = 1,
		victory_point = 4,
		territory_point = 1,
		hq = 0,
		production1 = 0,
		production2 = 0,
		production3 = 0,
		production4 = 0,
		forward_barracks = 0,
		-- Enabling all bridges
		bridge = 1,
		-- Enabling wrecks
		wreck = 1,
	})
	AI_SetTable(enemy_player, "t_personality_tuning", "defend_unit_tags_multipliers", {
		capture = 1,
		victory_point = 4,
		territory_point = 1,
		hq = 4,
		production1 = 0,
		production2 = 0,
		production3 = 0,
		production4 = 0,
		forward_barracks = 0,
	})
	
	Affectors_StartPartisanObservation(_skirmish.victory_points, 2)

	-- Designate a VP as linchpin of defense
	_skirmish.eg_targets = EGroup_CreateUnique()
	local pos = Util_ScarPos(0,0)
	local linchpin = Skirmish_GetMarkers("mkr_key_vp", local_player, false)
	if linchpin then
		pos = Marker_GetPosition(linchpin)
	end
	local shortest_distance = 9999
	local nearest_vp
	for i = EGroup_Count(_skirmish.victory_points), 1, -1 do
		local vp = EGroup_GetEntityAt(_skirmish.victory_points, i)
		local distance =  Util_GetDistance(pos, vp)
		if distance < shortest_distance then
			shortest_distance = distance
			nearest_vp = vp
		end
	end
	EGroup_Add(_skirmish.eg_targets, nearest_vp)
	--Entity_SetPlayerOwner(nearest_vp, local_player)

	-- Spawn a squad of infantry nearby
	local sbp = basic_infantry_sbp[Player_GetRaceName(local_player)]
	local start = Player_GetStartingPosition(local_player)
	local pos = World_GetOffsetPosition(Util_GetPosition(nearest_vp), Util_GetDirectionFromAtoB(Util_GetPosition(nearest_vp), start), OFFSET_FRONT, 9.0)
	Squad_Spawn(Squad_CreateToward(sbp, local_player, 0, pos, Util_GetPosition(nearest_vp)), pos, "none")

	primary = {
		Title = _skirmish.narrative.defend_vp.obj_text, 	--"Control victory points to exhaust enemy reserves"
		Type = OT_Primary,
		Intel_Start = function()
				CTRL.Event_Delay(2)
				CTRL.WAIT()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.defend_vp.intro1)
				CTRL.WAIT()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.defend_vp.intro2)
				CTRL.WAIT()
			end,
		OnStart = function()
			Objective_Start(subobjective, true, false)
			Objective_AddUIElements(subobjective, _skirmish.eg_targets, true, Loc_Empty(), true, 2, nil, nil, nil, "PrimaryObjectiveDataTemplate")
			Modifier_ApplyToEntity(Modifier_Create(MAT_Entity, "strategic_point_capture_ticks_modifier", MUT_Multiplication, false, 40 / 20, ""), EGroup_GetEntityAt(_skirmish.eg_targets, 1), 0)
			Rule_AddInterval(DefendVP_CaptureWarning, 45)
		end,
		IsComplete = function()
			return Skirmish_HasPlayerWon()
		end,
		IsFailed = function()
			return Skirmish_HasPlayerLost() or Objective_AreSubObjectivesFailed(primary, ANY)
		end,
		OnComplete = function()
			Core_CallDelegateFunctions("OnWinConditionTriggered", Skirmish_CreateMatchResult(local_player))
		end,
		OnFail = function()
			Core_CallDelegateFunctions("OnWinConditionTriggered", Skirmish_CreateMatchResult(enemy_player))
		end,
		Intel_Complete = function()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.defend_vp.victory)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		Intel_Fail = function()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.defend_vp.defeat)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		PreComplete = function()
			Objective_Complete(subobjective, true, false)
			Skirmish_FailBonusObjective()
		end,
		PreFail = Skirmish_FailBonusObjective,
	}		
	subobjective = {
		Title = _skirmish.narrative.defend_vp.subobj_text, --"Prevent enemy from capturing the central victory point"
		Type = OT_Primary,
		Parent = primary,
		IsFailed = function()	
			local failed
			EGroup_ForEach(_skirmish.eg_targets, function(eg, i, entity)
					failed = failed or (not World_OwnsEntity(entity) and not Player_IsHuman(Entity_GetPlayerOwner(entity)))
					if failed then
						Rule_Remove(DefendVP_CaptureWarning)
						Core_CallDelegateFunctions("OnWinConditionTriggered", Skirmish_CreateMatchResult(enemy_player, WR_VICTORY_POINT))
					end
				end)
			return Skirmish_HasPlayerLost()
		end,
	}		
	Objective_Register(primary)
	Objective_Register(subobjective)
end

function DefendVP_CameraFocus()
	local point = EGroup_GetEntityAt(_skirmish.eg_targets, 1)
	Camera_FocusOnPosition(Util_GetPosition(point))
end

function DefendVP_CaptureWarning()
	local point = EGroup_GetEntityAt(_skirmish.eg_targets, 1)
	if World_OwnsEntity(point) or Entity_GetPlayerOwner(point) ~= local_player then
		EventCue_Create("$11167555", "medium_priority", point, "icons/objectives/objective_primary", "", "")	-- "Hold the Line"
		UI_CreateMinimapBlip(Entity_GetPosition(point), 10.0, "attack_here")
	end
end

-- Territory control mode
function Skirmish_InitModeTerritory()

	Skirmish_RemoveVictoryPoints()
	Core_UnregisterModule("VictoryPoint")
	Core_UnregisterModule("EntityLoss")
	TicketUI_SetVisibility(true, false, false, 26)
	
	local settings = Territory_GetParameters()
	Territory_SetParameters({
			threshold = 0.5,
			ticket_loss_max = 5,
		})
	
	Affectors_StartPartisanObservation()

	primary = {
		Title = _skirmish.narrative.territory.obj_text,
		Type = OT_Primary,
		Intel_Start = function()
			CTRL.Event_Delay(2)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.territory.intro1)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.territory.intro2)
			CTRL.WAIT()
		end,
		OnStart = function()
			subobjective = Obj_Create(local_player, "$11231865", Loc_Empty(), "", "SubObjectiveDataTemplate", Player_GetRaceName(local_player), OT_Primary, primary.ID)
			Obj_SetState(subobjective, OS_Incomplete)
			Obj_SetVisible(subobjective, true)
			Rule_AddInterval(Skirmish_UpdateWinTerritory, 1, nil, mission_rule)
		end,
		IsComplete = Skirmish_HasPlayerWon,
		IsFailed = Skirmish_HasPlayerLost,
		OnComplete = function()
			Core_CallDelegateFunctions("OnWinConditionTriggered", Skirmish_CreateMatchResult(local_player))
		end,
		OnFail = function()
			Core_CallDelegateFunctions("OnWinConditionTriggered", Skirmish_CreateMatchResult(enemy_player))
		end,
		Intel_Complete = function()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.territory.victory)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		Intel_Fail = function()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.territory.defeat)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration) 
		end,
		PreComplete = Skirmish_FailBonusObjective,
		PreFail = function()
			Rule_Remove(Skirmish_UpdateWinTerritory)
			Obj_SetState(subobjective, OS_Failed)
			Skirmish_FailBonusObjective()
		end,
	}
	Objective_Register(primary)
end


-- Rule that updates the objectives used for the territory mode
function Skirmish_UpdateWinTerritory(context, data)
	local territory_advantage = Territory_GetAdvantage(local_player)
	if territory_advantage > 0 then
		Obj_SetState(subobjective, OS_Complete)
	else
		Obj_SetState(subobjective, OS_Incomplete)
	end
end


-- VP + Rout 
function Skirmish_InitModeRout()
	
	Core_UnregisterModule("Territory")
	Core_UnregisterModule("EntityLoss")
	TicketUI_SetVisibility(true, true, false)

	Affectors_StartPartisanObservation(_skirmish.victory_points, 2)
	
	AI_SetTable(enemy_player, "t_personality_tuning", "attack_unit_tags_multipliers", {
		capture = 1,
		victory_point = 4,
		territory_point = 1,
		hq = 0,
		production1 = 0,
		production2 = 0,
		production3 = 0,
		production4 = 0,
		forward_barracks = 0,
		-- Enabling all bridges
		bridge = 1,
		-- Enabling wrecks
		wreck = 1,
	})
	AI_SetTable(enemy_player, "t_personality_tuning", "defend_unit_tags_multipliers", {
		capture = 1,
		victory_point = 4,
		territory_point = 1,
		hq = 4,
		production1 = 0,
		production2 = 0,
		production3 = 0,
		production4 = 0,
		forward_barracks = 0,
	})

	-- Spawn defending squads in buildings near VPs
	AI_Enable(unused_player, true)	-- Using other enemy player to avoid affecting pop cap of enemy_player
	EGroup_ForEach(_skirmish.victory_points, 
		function (egroup, index, vp)
			if World_GetRand(1,100) <= Scale(1,100) then
				local eg_buildings = EGroup_CreateUnique()
				local sg = SGroup_CreateUnique()
				World_GetNeutralEntitiesNearPoint(eg_buildings, Entity_GetPosition(vp), 35)
				EGroup_ForEach(eg_buildings, function(eg, i, e)
						if not (Entity_IsActive(e)
								and Entity_IsOfType(e, "building")
								and Entity_ExtensionExist(e, "hold_ext")
								and Entity_GetHealthPercentage(e) > 0.3) then
							EGroup_Remove(eg_buildings, e)
						end
					end)
				if EGroup_Count(eg_buildings) > 0 then
					-- Spawn and garrison HMG team
					local eg_building = EGroup_CreateUnique()
					EGroup_Add(eg_building, EGroup_GetEntityAt(eg_buildings, World_GetRand(1,EGroup_Count(eg_buildings))))
					--Util_CreateSquads(unused_player, sg, SBP.GERMAN.HMG_MG42_GER, eg_building)		-- BUG: Garrisoned squads visisble on minimap!
					Util_CreateSquads(unused_player, sg, SBP.GERMAN.HMG_MG42_GER, EGroup_GetPosition(eg_building))
					Cmd_Garrison(sg, eg_building, false, true)
					AI_LockSquads(unused_player, sg)
					EGroup_Destroy(eg_building)
				else
					-- Spawn infantry nearby
					local sbps = {SBP.GERMAN.GRENADIER_GER, SBP.GERMAN.PANZERGRENADIER_GER, SBP.GERMAN.JAEGER_GER}
					Util_CreateSquads(unused_player, nil, sbps[World_GetRand(1,#sbps)], Prox_GetRandomPosition(vp, 16, 15))
					local ai_prefab = AI_AddPrefab(unused_player, "Defend_"..index, "Defend", 30, 1, 1, false, true)
					AI_SetPrefabTarget_Position(ai_prefab, unused_player, Entity_GetPosition(vp))
				end
				EGroup_Destroy(eg_buildings)
				SGroup_Destroy(sg)
			end
		end)


	primary = {
		Title = _skirmish.narrative.rout.obj_text, -- "Control victory points to exhaust enemy reserves"
		Type = OT_Primary,
		Intel_Start = function()
			CTRL.Event_Delay(2)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.rout.intro1)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.rout.intro2)
			CTRL.WAIT()			
		end,
		OnStart = function()
			Objective_Start(subobjective, true, false)
			Rule_AddInterval(Skirmish_UpdateRoutObjective, 1.0)
		end,
		IsComplete = function()
			return Skirmish_HasPlayerWon() or Objective_AreSubObjectivesComplete(primary, ANY)
		end,
		OnComplete = function()
			Core_CallDelegateFunctions("OnWinConditionTriggered", Skirmish_CreateMatchResult(local_player))
		end,
		OnFail = function()
			Core_CallDelegateFunctions("OnWinConditionTriggered", Skirmish_CreateMatchResult(enemy_player))
		end,
		Intel_Complete = function()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.rout.victory)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		IsFailed = function()
			return Skirmish_HasPlayerLost() or Objective_AreSubObjectivesFailed(primary, ANY)
		end,
		Intel_Fail = function()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.rout.defeat)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		PreComplete = Skirmish_FailBonusObjective,
		PreFail = Skirmish_FailBonusObjective,
	}		
	subobjective = {
		Title =  _skirmish.narrative.rout.subobj1_text,--"Capture all victory points to trigger a rout",
		Type = OT_Primary, 
		Parent = primary,
		rout_threshold = EGroup_Count(_skirmish.victory_points),
		rout_time = 90,
		points = {},
	}
	subobjective.points[World_GetPlayerIndex(local_player)] = Player_GetNumVictoryPoints(local_player)
	subobjective.points[World_GetPlayerIndex(enemy_player)] = Player_GetNumVictoryPoints(enemy_player)
	
	-- Override countdown period
	if Misc_IsCommandLineOptionSet("timer") and tonumber(Misc_GetCommandLineString("timer")) ~= nil then
		subobjective.rout_time = tonumber(Misc_GetCommandLineString("timer"))
	end
	
	Objective_Register(primary)
	Objective_Register(subobjective)
end


function Skirmish_UpdateRoutObjective(context, data)
	for player_index, _ in Table_DeterministicOrderedPairs(subobjective.points) do
		-- Update VP count
		local points = Player_GetNumVictoryPoints(World_GetPlayerAt(player_index))

		if points >= subobjective.rout_threshold then
			if not subobjective.rout_is_imminent then
				subobjective.rout_is_imminent = true
				if player_index == World_GetPlayerIndex(local_player) then
					subobjective.Title = _skirmish.narrative.rout.subobj2_text	-- "Defend all victory points to trigger a rout"
					Obj_SetTitle(subobjective.ID, subobjective.Title)
					
					Skirmish_PushVictoryPoints()
					Skirmish_Counterstrike(Skirmish_GetTargets(2, true, false))
				else
					subobjective.Title = _skirmish.narrative.rout.subobj3_text	-- "Neutralize a victory point"
					Obj_SetTitle(subobjective.ID, subobjective.Title)	
					Obj_CreatePopup(subobjective.ID, subobjective.Title)
					Music_PlayStinger("sfx_ui_event_queue_campaign_objective_start")
				end
				Objective_StartTimer(subobjective, COUNT_DOWN, subobjective.rout_time)
			else
				-- Victory check
				if Timer_GetRemaining(subobjective.Counter.TimerID) == 0 then
					Rule_RemoveMe()
					if player_index == World_GetPlayerIndex(local_player) then
						_skirmish.match_result = Skirmish_CreateMatchResult(local_player, WR_VICTORY_POINT)
						Skirmish_Rout()
						Objective_Complete(subobjective)
					else
						_skirmish.match_result = Skirmish_CreateMatchResult(enemy_player, WR_VICTORY_POINT)
						Skirmish_Rout()
						Objective_Fail(subobjective)
					end
				end
			end
		elseif points < subobjective.rout_threshold and subobjective.points[player_index] >= subobjective.rout_threshold then
			subobjective.rout_is_imminent = false
			Objective_StopTimer(subobjective)
			subobjective.Title = _skirmish.narrative.rout.subobj1_text		-- "Capture all victory points to trigger a rout"
			Obj_SetTitle(subobjective.ID, subobjective.Title)
			if player_index == World_GetPlayerIndex(local_player) then 
				Obj_SetCounterType(subobjective.ID, COUNTER_CountUpTo)
				Obj_SetCounterCount(subobjective.ID, points)
				Obj_SetCounterMax(subobjective.ID, subobjective.rout_threshold)
			end
		elseif player_index == World_GetPlayerIndex(local_player) and not subobjective.rout_is_imminent then
			Obj_SetCounterType(subobjective.ID, COUNTER_CountUpTo)
			Obj_SetCounterCount(subobjective.ID, points)
			Obj_SetCounterMax(subobjective.ID, subobjective.rout_threshold)
		end
		subobjective.points[player_index] = points
	end
end



function Skirmish_Rout()

	-- Grant winners invulnerability
	for _, player_index in pairs(_skirmish.match_result.winners) do
		local player = World_GetPlayerAt(player_index)
		SGroup_SetInvulnerable(Player_GetSquads(player), true)
	end
	
	-- Losing units flee
	for _, player_index in pairs(_skirmish.match_result.losers) do 
		local defeated_player = World_GetPlayerAt(player_index)
		local sg = Player_GetSquads(defeated_player)
		local sg_vehicles = SGroup_CreateUnique()
		SGroup_Filter(sg, "vehicle", FILTER_REMOVE, sg_vehicles)
		SGroup_Filter(sg,  {"building", "base_defense", "auto_builder", "airplane"}, FILTER_REMOVE)
		SGroup_Filter(sg_vehicles, "airplane", FILTER_REMOVE)
		
		if Player_IsHuman(defeated_player) then
			Misc_ClearSelection()
			Misc_SetSGroupSelectable(sg, false)
			Misc_SetSGroupSelectable(sg_vehicles, false)
		else
			AI_Enable(defeated_player, false)
			Player_SetPopCapOverride(defeated_player, 0)	-- Stop production
		end

		Cmd_StaggeredRetreat(sg, {Skirmish_GetMapEntryPosition(defeated_player)}, 5, false)
		
		--TODO: Stop/cancel unit production?
		
		if SGroup_CountSpawned(sg_vehicles) > 0 then
			Cmd_MoveToAndDeSpawn(sg_vehicles, Skirmish_GetMapEntryPosition(defeated_player), false)
		end
	end
end

-- Encirclement mode
function Skirmish_InitModeCutoff(attacker, narrative)
	Skirmish_RemoveVictoryPoints()
	Core_UnregisterModule("Tickets")
	Core_UnregisterModule("VictoryPoint")
	Core_UnregisterModule("Territory")
	Core_UnregisterModule("EntityLoss")
	
	TicketUI_SetVisibility(nil, nil, false)

	-- Get territory points adjacent to each player's base
	local points = {}
	local _GetAdjacentSectorCreators = function(player)
		local i = World_GetPlayerIndex(player)
		if points[i] ==  nil then 
			points[i] = {}
		end
		local sectors = Territory_GetAdjacentSectors(Territory_FindClosestSectorToPoint(Player_GetStartingPosition(player)))
		for j = 1, #sectors do 
			local entity = Territory_GetSectorCreatorEntity(sectors[j])
			if Entity_GetBlueprint(entity) ~= BP_GetEntityBlueprint("starting_territory_team") then 
				table.insert(points[i], entity)
			end
		end
	end
	_GetAdjacentSectorCreators(local_player)
	_GetAdjacentSectorCreators(enemy_player)

	-- Spawn defending infantry
	AI_Enable(unused_player, true)
	local sbps = {SBP.GERMAN.GRENADIER_GER, SBP.GERMAN.PANZERGRENADIER_GER, SBP.GERMAN.JAEGER_GER}
	local enemy_points = points[World_GetPlayerIndex(enemy_player)]
	for i = 1, #enemy_points do
		local pos = Util_GetPosition(enemy_points[i])
		local spawn_pos = Prox_GetRandomPosition(pos, 17, 16)
		while World_GetInteractionStageAtPoint(spawn_pos) ~= 0 do
			spawn_pos = Prox_GetRandomPosition(pos, 17, 16)
		end
		Util_CreateSquads(unused_player, nil, sbps[World_GetRand(1,#sbps)], spawn_pos)
		local ai_prefab = AI_AddPrefab(unused_player, "Defend_cutoff_"..i, "Defend", 30, 1, 1, false, true)
		AI_SetPrefabTarget_Position(ai_prefab, unused_player, pos)
	end
	
	Affectors_StartPartisanObservation(points[World_GetPlayerIndex(enemy_player)], 2)
		
	primary = {
		Title = narrative.obj_text1,	--"Capture all territory around enemy base"
		Type = OT_Primary,
		Intel_Start = function()
			CTRL.Event_Delay(2)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(narrative.vo_intro1)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(narrative.vo_intro2)
			CTRL.WAIT()
		end,
		OnStart = function()
			Rule_AddInterval(Skirmish_UpdateCutoffObjective, 1.0)
			for _, point in pairs(primary.points[World_GetPlayerIndex(enemy_player)]) do
				UI_CreateMinimapBlip(Entity_GetPosition(point), 30.0, "attack_here")
			end
		end,
		IsComplete = function()
			return Skirmish_HasPlayerWon()
		end,
		IsFailed = function()
			return Objective_AreSubObjectivesFailed(primary, ANY) or Skirmish_HasPlayerLost()
		end,
		OnComplete = function()
			Core_CallDelegateFunctions("OnWinConditionTriggered", _skirmish.match_result or Skirmish_CreateMatchResult(local_player))
		end,
		OnFail = function()
			Core_CallDelegateFunctions("OnWinConditionTriggered", _skirmish.match_result or Skirmish_CreateMatchResult(enemy_player))
		end,
		Intel_Complete = function()
			CTRL.Event_Delay(2)
			CTRL.Subtitle_PlayNarrativeEvent(primary.narrative.vo_victory)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		Intel_Fail = function()
			CTRL.Event_Delay(2)
			CTRL.Subtitle_PlayNarrativeEvent(primary.narrative.vo_defeat)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		PreComplete = Skirmish_FailBonusObjective,
		PreFail = Skirmish_FailBonusObjective,
		rout_time = Scale({70, 80, 90, 100, 120}),
		points = points,
		narrative = narrative,
	}

	subobj = {
		Title = narrative.subobj_text,		-- "Break the enemy encirclement"
		Type = OT_Primary, 
		Parent = primary,
		rout_time = Scale({120, 110, 100, 90}),
		points = points,
	}
	Objective_Register(primary)
	Objective_Register(subobj)

	-- Override hold/breakout time
	if Misc_IsCommandLineOptionSet("timer") and tonumber(Misc_GetCommandLineString("timer")) ~= nil then
		primary.rout_time = tonumber(Misc_GetCommandLineString("timer"))
		subobj.rout_time = primary.rout_time
	end
end


-- Updates state of cutoff objectives
function Skirmish_UpdateCutoffObjective(context, data)
	for player_index, points in Table_DeterministicOrderedPairs(primary.points) do
		local points_owned_by_enemy = {}
		for _, point in pairs(points) do
			if  not World_OwnsEntity(point) and Player_ObserveRelationship(Entity_GetPlayerOwner(point), World_GetPlayerAt(player_index)) == R_ENEMY then
				table.insert(points_owned_by_enemy, point)
			end
		end

		if player_index == World_GetPlayerIndex(local_player) then
			if #points_owned_by_enemy >= #points then
				-- Player is cut off
				if not subobj.is_cutoff then 
					subobj.is_cutoff = true
					Util_StartIntel(function()
							CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.attack_cutoff.vo_subobj_start)	-- "Break out!"
							CTRL.WAIT()
						end)
					if not Objective_IsStarted(subobj) then
						Objective_Start(subobj)
					else
						Obj_SetVisible(subobj.ID, true)
					end
					Objective_StartTimer(subobj, COUNT_DOWN, subobj.rout_time)
					for _, point in pairs(points) do
						UI_CreateMinimapBlip(Entity_GetPosition(point), 10.0, "attack_here")
					end
				elseif Timer_GetRemaining(subobj.Counter.TimerID) == 0 then
					-- Player defeated
					Rule_RemoveMe()
					_skirmish.match_result = Skirmish_CreateMatchResult(enemy_player)
					Skirmish_Rout()
					Objective_Fail(subobj, true)
				end
			else
				if subobj.is_cutoff then
					-- Player no longer cut off
					subobj.is_cutoff = false
					Timer_End(subobj.Counter.TimerID)
					Obj_SetVisible(subobj.ID, false)
				end
			end
		else
			if #points_owned_by_enemy >= #points then
				-- Enemy is cutoff
				if not primary.is_cutoff then 
					primary.is_cutoff = true
					primary.Title = _skirmish.narrative.attack_cutoff.obj_text2		-- "Hold"
					Obj_SetTitle(primary.ID, primary.Title)
					Objective_StartTimer(primary, COUNT_DOWN, primary.rout_time)
					Util_StartIntel(function()
							CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.attack_cutoff.vo_obj_done)	-- "Hold!"
							CTRL.WAIT()
						end)
					for _, point in pairs(points) do
						UI_CreateMinimapBlip(Entity_GetPosition(point), 10.0, "attack_here")
					end
					Skirmish_Counterstrike(points_owned_by_enemy)
				elseif Timer_GetRemaining(primary.Counter.TimerID) == 0 then
					-- Enemy defeated
					Rule_RemoveMe()
					_skirmish.match_result = Skirmish_CreateMatchResult(local_player)
					Skirmish_Rout()
					Objective_Complete(primary, true)
				end
			else
				-- Enemy not cut off
				if primary.is_cutoff then 
					primary.is_cutoff = false
					primary.Title = _skirmish.narrative.attack_cutoff.obj_text1		-- "Capture"
					Obj_SetTitle(primary.ID, primary.Title)
					Util_StartIntel(function()
							CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.attack_cutoff.vo_obj_fail)	-- "Enemy broke through."
							CTRL.WAIT()
						end)
					for _, point in pairs(points) do
						if World_OwnsEntity(point) or Entity_GetPlayerOwner(point) ~= local_player then
							UI_CreateMinimapBlip(Entity_GetPosition(point), 10.0, "attack_here")
						end
					end
				end	
				Obj_SetCounterType(primary.ID, COUNTER_CountUpTo)
				Obj_SetCounterCount(primary.ID, #points_owned_by_enemy)
				Obj_SetCounterMax(primary.ID, #points)
			end
		end
	end
end


-- Knockout mode
function Skirmish_InitModeKnockout()

	Skirmish_RemoveVictoryPoints()
	Core_UnregisterModule("VictoryPoint")
	Core_UnregisterModule("Territory")
	TicketUI_SetVisibility(true, false, false)

	Affectors_StartPartisanObservation()
	
	-- Explicitly set parameters in order to be independent of multi-player 
	EntityLoss_SetParameters({
			ticket_cost = 20,			-- resource value of one ticket
			attrition_factor = 1.0,		-- factor applied to ticket cost (for ease of tuning)
			fuel_factor = 1.6,			-- factor applied to fuel cost to determine entity value
			building_factor = 2.0,		-- factor applied to building cost to determine entity value
			team_size_factor = 0.0,		-- disable scaling based on team size
			upgrade_factor = 1.0,		-- factor applied to upgrade costs to determine entity value
			squad_wipe_bonus = 1,		-- bonus when last member of a squad is killed (for squads with 2+ entities)
			veterancy_rank_bonus = 0.3,	-- bonus for each veterancy rank
		})

	primary = {	
		Title = _skirmish.narrative.knockout.obj_text,	--"Inflict damage to break enemy morale"
		Type = OT_Primary,
		Intel_Start = function()
			CTRL.Event_Delay(2)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.knockout.intro1)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.knockout.intro2)
			CTRL.WAIT()
		end,
		IsFailed = Skirmish_HasPlayerLost,
		IsComplete = Skirmish_HasPlayerWon,
		OnComplete = function()
			Core_CallDelegateFunctions("OnWinConditionTriggered", Skirmish_CreateMatchResult(local_player))
		end,
		OnFail = function()
			Core_CallDelegateFunctions("OnWinConditionTriggered", Skirmish_CreateMatchResult(enemy_player))
		end,
		Intel_Complete = function()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.knockout.victory)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		Intel_Fail = function()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.knockout.defeat)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration) 
		end,
		PreComplete = Skirmish_FailBonusObjective,
		PreFail = Skirmish_FailBonusObjective,
	}
	Objective_Register(primary)
end


function Skirmish_CreateMatchResult(winner, win_reason, point_of_interest)
	local match_result = {
		winners = {},		-- table of player indices for the winning players
		losers = {},		-- table of player indices for the losing players
		win_reason = win_reason or WR_NONE,		-- the win condition that was triggered
		point_of_interest = point_of_interest
	}
	for i = 1, World_GetPlayerCount() do	 
		if Player_ObserveRelationship(winner, World_GetPlayerAt(i)) == R_ALLY then 
			table.insert(match_result.winners, i)
		else
			table.insert(match_result.losers, i)
		end
	end
	return match_result
end


-----------------------------------------------------------------------
-- Fixed Force (defense)
-----------------------------------------------------------------------

function Skirmish_InitModeFixedForceDefense(attacker, defender, narrative)
	Skirmish_RemoveVictoryPoints()
	Skirmish_HideTerritoryPoints(local_player)
	Core_UnregisterModule("DestroyHQ")
	Core_UnregisterModule("Tickets")
	Core_UnregisterModule("Territory")
	Core_UnregisterModule("EntityLoss")
	Core_UnregisterModule("VictoryPoint")
	
	TicketUI_SetVisibility(false, false, false)

	Rule_AddInterval(Skirmish_UpdateTerritory, 10, nil, mission_rule)

	local _RemoveDefaultStuff = function(player, exclusions)
		local eg = Player_GetEntities(player)
		for i = 1, #exclusions do
			if scartype(exclusions[i]) == ST_STRING then
				exclusions[i] = BP_GetEntityBlueprint(exclusions[i])
			end
		end
		EGroup_Filter(eg, exclusions, FILTER_REMOVE)
		EGroup_DeSpawn(eg)
		SGroup_DeSpawn(Player_GetSquads(player))
	end
	_RemoveDefaultStuff(enemy_player, {"starting_territory_team", "map_entry_point", "map_entry_point_player", "starting_position", "starting_position_no_hq", "retreat_point" })
	_RemoveDefaultStuff(local_player, {"starting_territory_team", "map_entry_point", "map_entry_point_player", "starting_position", "starting_position_no_hq", "retreat_point", "territory_creator_invisible" })
	
	-- Spawn objectives (bunkers, etc.)
	local m = Table_Concatenate(Skirmish_GetMarkers("mkr_bunker", local_player, true), Skirmish_GetMarkers("mkr_bunker_rear", local_player, true))
	local markers = { m[World_GetRand(1, #m)] }		-- Pick a defensive position at random
	table.sort(m, 
		function(a, b)
			return Util_GetDistance(a, markers[1]) < Util_GetDistance(b, markers[1])
		end)
	table.insert(markers, m[World_GetRand(2, 3)])	-- Ensure second defensive position is near the first
	table.sort(markers, 
		function(a, b)
			return Util_GetDistance(a, Player_GetStartingPosition(local_player)) < Util_GetDistance(b, Player_GetStartingPosition(local_player))
		end)

	local targets = {}
	local target_list = {
		americans = {
			{ SBP.AMERICAN.BASE_DEFENSE_US },
			{ SBP.AMERICAN.HOWITZER_105MM_US },
		},
		british = {
			{ SBP.BRITISH.BASE_DEFENSE_UK },
			{ SBP.BRITISH.HOWITZER_25PDR_UK },
			--{ SBP.BRITISH.HOWITZER_BL_5_5_UK },
		},
	}
	target_list = Table_GetRand(target_list[Player_GetRaceName(local_player)], #markers)

	local _SpawnTargetAt = function(marker, bp, upgrade)
		local facing = Util_GetOffsetPosition(marker, OFFSET_FRONT, 10)
		if SBP_Exists(BP_GetName(bp)) then
			local sg = SGroup_CreateUnique()
			Util_CreateSquads(local_player, sg, bp, marker, marker, 1, nil, false, nil, upgrades, facing)
			table.insert(targets, SGroup_GetSquadAt(sg, 1))

			-- Buff objective targets
			SGroup_ForEach(sg,  function(sgroup, index, squad)
					local mod_health = Modifier_Create(MAT_Entity, "health_maximum_modifier", MUT_Multiplication, false, Scale({3.0, 2.5, 2.0, 1.5, 1.0}), "")
					for i = 1, Squad_Count(squad) do
						local entity = Squad_EntityAt(squad, i-1)
						if Entity_ExtensionExist(entity, "modifier_ext") and Entity_IsActive(entity) then
							Modifier_ApplyToEntity(mod_health, entity, 0)
						end
					end
					local artillery_abilities = {
						ABILITY.BRITISH.BARRAGE_HOWITZER_25PDR_AIRBURST_UK,
						ABILITY.BRITISH.BARRAGE_HOWITZER_25PDR_AIRBURST_VET_UK,
						ABILITY.BRITISH.BARRAGE_HOWITZER_25PDR_AP_UK,
						ABILITY.BRITISH.BARRAGE_HOWITZER_25PDR_UK,
						ABILITY.BRITISH.BARRAGE_HOWITZER_25PDR_UK_SP,
						ABILITY.AMERICAN.BARRAGE_HOWITZER_105MM_US,
					}
					for _, ability in pairs(artillery_abilities) do
						if Squad_HasAbility(squad, ability) then
							Modify_AbilityRechargeTime(squad, ability, 0.15, MUT_Multiplication)
						end
					end
					Squad_SetRecrewable(squad, false)
				end)
			SGroup_Destroy(sg)
		else
			local eg = EGroup_CreateUnique()
			Util_CreateEntities(local_player, eg, bp, marker, 1, facing, true, false, true)
			table.insert(targets, EGroup_GetEntityAt(eg, 1))
			EGroup_Destroy(eg)
		end

		-- Spawn medical crates
		--local _SpawnCrate = function(ebp, pos)
			--local entity = Entity_CreateENVFacing(ebp, pos, Prox_GetRandomPosition(pos, 10, 10), true)
			--Entity_SetPosition(entity, Entity_CalculatePassableSpawnPosition(entity, pos))
			--Entity_Spawn(entity)
		--end
		--local offsets = { OFFSET_BACK_LEFT, OFFSET_BACK, OFFSET_BACK_RIGHT }
		--local offset = offsets[World_GetRand(1, #offsets)]
		--local pos = Util_GetPosition(targets[#targets])
		--_SpawnCrate(EBP.AMERICAN.MEDICAL_CRATE_US, Util_GetOffsetPosition(pos, offset, 7 + World_GetRand(1,20)/10))
	end

	for i, marker in pairs(markers) do
		_SpawnTargetAt(marker, target_list[i][1], target_list[i][2])
	end
	
	-- Initial engagement location
	Camera_MoveTo(Marker_GetPosition(markers[1]), nil, nil, nil, true)
	Camera_SetInputEnabled(false)

	-- Disable resource income
	for i = 1, World_GetPlayerCount() do 
		local player = World_GetPlayerAt(i)
		Player_CompleteUpgrade(player, BP_GetUpgradeBlueprint("disable_passive_resource_income"))
	end

	-- Initial resources and income
	Anvil_SetPlayerResources(local_player, 0, 0, 0)
	Skirmish_InitStartingResources(local_player, { 0, 0, Scale({1000,900,800,700,600}), Scale({250,225,200,175,150})}, true)	-- action?, fuel, manpower, munition
	Skirmish_InitStartingResources(enemy_player, { 0, 0, 600, 400 }, true)	-- action?, fuel, manpower, munition

	-- Enemy behaviour
	AI_SetPersonality(enemy_player, "mission_ai_personality.xml")

	-- Affectors
	local points_to_observe = {}
	for _, target in pairs(targets) do
		local pos = Util_GetPositionFromAtoB(Util_GetPosition(target), Skirmish_GetMapEntryPosition(enemy_player), 80)
		table.insert(points_to_observe, pos)
	end
	Affectors_StartPartisanObservation(points_to_observe)

	-- Retreat points
	local _CreateEntity = function (ebp, position, owner)
		local pos = Entity_FindConstructionLocation(owner, ebp, position, 15, 1)
		local entity = Entity_CreateFacing(ebp, owner, pos, Util_ScarPos(0,0), true)
		Entity_Spawn(entity)
		Entity_ForceConstruct(entity)
		World_UpdatePathfindingBlockers()
	end
	_CreateEntity(BP_GetEntityBlueprint("retreat_point"), Player_GetStartingPosition(enemy_player), enemy_player)
	if Player_GetRace(local_player) == RACE.BRITISH then
		_CreateEntity(EBP.BRITISH.RALLY_POINT_UK, Util_GetPosition(Skirmish_GetMarkers("mkr_base", local_player)), local_player)
	else
		_CreateEntity(EBP.AMERICAN.RALLY_POINT_US, Util_GetPosition(Skirmish_GetMarkers("mkr_base", local_player)), local_player)
	end

	-- Place a halftrack at AI's retreat point
	local mkr_enemy_base = Skirmish_GetMarkers("mkr_base", unused_player, false)
	local pos = Prox_GetRandomPosition(mkr_enemy_base, 10, 5)
	local facing = Util_GetOffsetPosition(mkr_enemy_base, OFFSET_FRONT, 10)
	local halftrack = Squad_CreateAndSpawnToward(SBP.GERMAN.HALFTRACK_MEDICAL_GER, unused_player, 1, pos, Util_ScarPos(0,0))
	Modifier_ApplyToEntity(Modifier_Create(MAT_Entity, "health_maximum_modifier", MUT_Multiplication, false, 3.0, ""),  Squad_EntityAt(halftrack, 0), 0)
	AI_LockSquad(unused_player, halftrack)

	-- Spawn units
	local diff_scale = Scale({0.2, 0.3, 0.4, 0.6, 0.8})
	_fixed = {
		company_infantry_us = {
			{1, SBP.AMERICAN.HALFTRACK_US, "medical_halftrack_us" },
			{1, SBP.AMERICAN.ENGINEER_US, "flamethrower_engineer_us" },
			{1, SBP.AMERICAN.ENGINEER_US,  },
			{1, SBP.AMERICAN.RIFLEMEN_US, "bar_rifleman_squad_us" },
			{1, SBP.AMERICAN.BAZOOKA_TEAM_US, },
			{1, SBP.AMERICAN.SCOUT_US, },
			{1, SBP.AMERICAN.CHAFFEE_US,  },
			{1, SBP.AMERICAN.AT_GUN_57MM_US, },
			--{1, SBP.AMERICAN.GREYHOUND_US, },
		},
		company_paratrooper_us = {
			{1, SBP.AMERICAN.HALFTRACK_US, "medical_halftrack_us" },
			{1, SBP.AMERICAN.ENGINEER_US, "flamethrower_engineer_us" },
			{1, SBP.AMERICAN.ENGINEER_US, },
			{1, SBP.AMERICAN.RIFLEMEN_US, "bar_rifleman_squad_us" },
			{1, SBP.AMERICAN.PARATROOPER_US, "bazooka_paratrooper_us", },
			{1, SBP.AMERICAN.PATHFINDER_US},
			{1, SBP.AMERICAN.CHAFFEE_US,},
		},
		company_spec_ops_us = {
			{1, SBP.AMERICAN.HALFTRACK_US, "medical_halftrack_us" },
			{1, SBP.AMERICAN.ENGINEER_US, "flamethrower_engineer_us" },
			{1, SBP.AMERICAN.ENGINEER_US, },
			{1, SBP.AMERICAN.RIFLEMEN_US, "bar_rifleman_squad_us" },
			{1, SBP.AMERICAN.SSF_COMMANDOS_US, },
			{1, SBP.AMERICAN.SCOUT_US, },
			{1, SBP.AMERICAN.CHAFFEE_US,  },
			{1, SBP.AMERICAN.AT_GUN_57MM_US, },
			--{1, SBP.AMERICAN.GREYHOUND_US, },
		},
		company_armoured_us = {
			{1, SBP.AMERICAN.HALFTRACK_US, "medical_halftrack_us" },
			{1, SBP.AMERICAN.ASSAULT_ENGINEER_US, "flamethrower_engineer_us" },
			{1, SBP.AMERICAN.ASSAULT_ENGINEER_US, },
			{1, SBP.AMERICAN.RIFLEMEN_US, "bar_rifleman_squad_us" },
			{1, SBP.AMERICAN.BAZOOKA_TEAM_US, },
			{1, SBP.AMERICAN.SCOUT_US, },
			{Scale({0,0,1,1,1}), SBP.AMERICAN.CHAFFEE_US,  },
			{1, SBP.AMERICAN.AT_GUN_57MM_US, },
			{Scale({0,0,1,1,1}), SBP.AMERICAN.GREYHOUND_US, },
			{Scale({1,1,0,0,0}), SBP.AMERICAN.SHERMAN_US, },
		},
		company_airborne_uk = {
			{1, SBP.BRITISH.CWT_15_TRUCK_UK, "medical_truck_uk" },
			{1, SBP.BRITISH.SAPPER_UK, "flamethrower_sapper_uk" },
			{1, SBP.BRITISH.SAPPER_UK, },
			{1, SBP.BRITISH.TOMMY_UK, "lmg_bren_tommy_uk" },
			{1, SBP.BRITISH.TOMMY_UK, "recon_package_tommy_uk" },
			{1, SBP.BRITISH.GUARDS_UK, },
			{1, SBP.BRITISH.VALENTINE_UK, },
			--{1, SBP.BRITISH.STUART_UK, },
			--{1, SBP.BRITISH.HUMBER_UK, },
			--{1, SBP.BRITISH.GRANT_UK, },
			--{1, SBP.BRITISH.MATILDA_UK, },
			--{1, SBP.BRITISH.SHERMAN_UK, },
			{1, SBP.BRITISH.AT_GUN_6PDR_UK, },
			{1, SBP.BRITISH.HALFTRACK_M3_UK, },
		},
		company_artillery_uk = {
			{1, SBP.BRITISH.CWT_15_TRUCK_UK, "medical_truck_uk" },
			{1, SBP.BRITISH.SAPPER_UK, "flamethrower_sapper_uk" },
			{1, SBP.BRITISH.SAPPER_UK,},
			{1, SBP.BRITISH.TOMMY_UK, "lmg_bren_tommy_uk" },
			{1, SBP.BRITISH.TOMMY_UK, "boys_anti_tank_rifles_tommy_uk" },
			{1, SBP.BRITISH.GUARDS_UK, },
			{1, SBP.BRITISH.VALENTINE_UK, },
			--{1, SBP.BRITISH.STUART_UK, },
			--{1, SBP.BRITISH.HUMBER_UK, },
			--{1, SBP.BRITISH.GRANT_UK, },
			--{1, SBP.BRITISH.MATILDA_UK, },
			--{1, SBP.BRITISH.SHERMAN_UK, },
			{1, SBP.BRITISH.AT_GUN_6PDR_UK, },
			{1, SBP.BRITISH.HALFTRACK_M3_UK, },
		},
		company_armoured_uk = {
			{1, SBP.BRITISH.CWT_15_TRUCK_UK, "medical_truck_uk" },
			{1, SBP.BRITISH.SAPPER_UK, "flamethrower_sapper_uk" },
			{1, SBP.BRITISH.SAPPER_UK,},
			{1, SBP.BRITISH.TOMMY_UK, "recon_package_tommy_uk" },
			{1, SBP.BRITISH.TOMMY_UK, "boys_anti_tank_rifles_tommy_uk"},
			{1, SBP.BRITISH.GUARDS_UK, },
			--{1, SBP.BRITISH.VALENTINE_UK, },
			--{1, SBP.BRITISH.STUART_UK, },
			{1, SBP.BRITISH.HUMBER_UK, },
			--{1, SBP.BRITISH.GRANT_UK, },
			--{1, SBP.BRITISH.MATILDA_UK, },
			{1, SBP.BRITISH.SHERMAN_UK, },
			{1, SBP.BRITISH.AT_GUN_6PDR_UK, },
			--{1, SBP.BRITISH.HALFTRACK_M3_UK, },
		},
		company_infantry_ger = {
			{Scale({1,1,1,2,2}), SBP.GERMAN.GRENADIER_GER, },
			{Scale({1,1,1,1,2}), SBP.GERMAN.ARMORED_CAR_GER, "20mm_panzerbuchse_armored_car_ger", diff_scale},
			{1, SBP.GERMAN.JAEGER_GER, "g43_jaeger_ger", diff_scale },
			{Scale({1,1,2,2,2}), SBP.GERMAN.PIONEER_GER, "flamethrower_pioneer_ger", diff_scale },
			{Scale({0,1,1,1,1}), SBP.GERMAN.MORTAR_81MM_GER, },
			{1, SBP.GERMAN.HALFTRACK_STUMMEL_GER, },
			{1, SBP.GERMAN.WESPE_GER, },
			{2, SBP.GERMAN.PIONEER_GER, "flamethrower_pioneer_ger", diff_scale },
			{Scale({1,1,1,1,2}), SBP.GERMAN.STUG_III_GER, "mg42_stug_ger", diff_scale },
			{1, SBP.GERMAN.JAEGER_GER, "panzerschrek_jaeger_ger", diff_scale },
			{1, SBP.GERMAN.JAEGER_GER, },
			{1, SBP.GERMAN.PANZER_IV_CMD_GER, },
		},
		company_luftwaffe_ger = {
			{2, SBP.GERMAN.GRENADIER_GER },
			{Scale({0,1,1,1,1}), SBP.GERMAN.MORTAR_81MM_GER, },
			{Scale({0,1,1,2,2}), SBP.GERMAN.FALLSCHIRMJAGERS_GER, },
			{1, SBP.GERMAN.WIRBELWIND_GER, },
			{2, SBP.GERMAN.FALLSCHIRMPIONEERS_GER, "grb_39_grenade_launcher_fallschirmpioneer_ger", diff_scale },
			{Scale({1,1,1,1,2}), SBP.GERMAN.STUG_III_GER, "mg42_stug_ger", diff_scale },
			{Scale({1,1,2,2,3}), SBP.GERMAN.FALLSCHIRMJAGERS_GER, },
			{Scale({0,1,1,2,2}), SBP.GERMAN.PANZER_IV_GER, "mg42_panzer_ger", diff_scale },
		},
		company_mechanized_ger = {
			{Scale({1,1,2,2,3}), SBP.GERMAN.JAEGER_GER, "panzerschrek_jaeger_ger", diff_scale },
			{1, SBP.GERMAN.PIONEER_GER, "flamethrower_pioneer_ger", diff_scale },
			{1, SBP.GERMAN.ARMORED_CAR_GER, "20mm_panzerbuchse_armored_car_ger", diff_scale},
			{Scale({0,1,1,1,1}), SBP.GERMAN.MORTAR_81MM_GER, },
			{Scale({1,1,1,2,2}), SBP.GERMAN.JAEGER_GER, "g43_jaeger_ger", diff_scale },
			{1, SBP.GERMAN.HALFTRACK_STUMMEL_GER, },
			{1, SBP.GERMAN.WESPE_GER, },
			{Scale({1,1,1,2,2}), SBP.GERMAN.JAEGER_GER, "g43_jaeger_ger", diff_scale },
			{Scale({1,1,1,1,2}), SBP.GERMAN.PANZER_IV_GER, "mg42_panzer_ger", diff_scale },
			{1, SBP.GERMAN.PIONEER_GER, "flamethrower_pioneer_ger", diff_scale },
			{1, SBP.GERMAN.STUG_III_GER, "mg42_stug_ger", diff_scale },
		},
		company_armored_ger = {
			{Scale({1,1,2,2,3}), SBP.GERMAN.JAEGER_GER, "panzerschrek_jaeger_ger", diff_scale },
			{Scale({1,1,2,2,2}), SBP.GERMAN.PANZERGRENADIER_GER },
			{Scale({1,1,2,2,2}), SBP.GERMAN.PIONEER_GER, "flamethrower_pioneer_ger", diff_scale },
			{Scale({1,1,1,2,2}), SBP.GERMAN.PANZER_IV_GER, "mg42_panzer_ger", diff_scale },
			{Scale({0,1,1,1,1}), SBP.GERMAN.MORTAR_81MM_GER, },
			{Scale({1,1,1,1,2}), SBP.GERMAN.STUG_III_GER, "mg42_stug_ger", diff_scale },
			{Scale({1,1,2,2,2}), SBP.GERMAN.PANZER_IV_GER, "mg42_panzer_ger", diff_scale },
			{1, SBP.GERMAN.PIONEER_GER, "flamethrower_pioneer_ger", diff_scale },
		},
	}

	-- Spawn defending squads
	local _SpawnSquads = function(spawn_list, player, sg, markers)
		local m = 0
		for _, spawn_data in pairs(spawn_list) do
			for i = 1, spawn_data[1] do 
				local upgrades = {}
				if spawn_data[3] then
					if spawn_data[4] then
						if World_GetRand(1,100) <= spawn_data[4] * 100 then
							table.insert(upgrades, BP_GetUpgradeBlueprint(spawn_data[3]))
						end
					else
						table.insert(upgrades, BP_GetUpgradeBlueprint(spawn_data[3]))
					end
				end
				m = (m % #markers)+1
				local marker = markers[m]
				local pos = Prox_GetRandomPosition(marker, 20, 12)
				-- Ensure spawn position is inside interactive zone
				while World_GetInteractionStageAtPoint(pos) ~= 0 do
					pos = Prox_GetRandomPosition(marker, 20, 12)
				end
				local facing = Util_GetOffsetPosition(marker, OFFSET_FRONT, 80)
				Util_CreateSquads(player, sg, spawn_data[2], pos, dest, nil, nil, false, nil, upgrades, facing)
				if Player_ObserveRelationship(local_player, player) == R_ENEMY then 
					UI_CreateMinimapBlip(pos, 10.0, "attack_here")
				end
			end
		end
	end
	Sound_Play2D("mix_mute_speech_on")
	_SpawnSquads(_fixed[_skirmish.company.player], local_player, SGroup_CreateIfNotFound("sg_defender"), targets)
	
	Rule_AddOneShot(Skirmish_SpawnReinforcements, 25.0, {player = local_player, destination = Util_GetPosition(targets[1])}, mission_rule)

	Skirmish_SetWeaponsDroppable(Player_GetSquads(local_player))

	local _GetName = function(thing)
		if scartype(thing) == ST_SQUAD then
			local ui_info = BP_GetSquadUIInfo(Squad_GetBlueprint(thing), Player_GetRace(Squad_GetPlayerOwner(thing)))
			return ui_info.screenName
		elseif scartype(thing) == ST_ENTITY then
			local ui_info = BP_GetEntityUIInfo(Entity_GetBlueprint(thing))
			return ui_info.screenName
		end
	end

	primary = {
		Title = narrative.obj_text,
		showTitle = true,
		Type = OT_Primary,
		Intel_Start = function()
			CTRL.Event_Delay(3)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(narrative.intro1)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(narrative.intro2)
			CTRL.WAIT()
		end,
		PreStart = function()
			primary.blip = UI_CreateMinimapBlip(Skirmish_GetMapEntryPosition(enemy_player), -1, "ThreatGroupDataTemplate")
			Rule_AddInterval(Skirmish_FixedDefendSpawnSquads, 45, nil, mission_rule)
		end,
		OnStart = function()
			Sound_Play2D ("mix_mute_speech_off")
			Camera_SetInputEnabled(true)
			-- Update subobjective titles and targets with names of squads (bunkers are weird...)
			local _ReplaceEntityWithSquad = function(obj, target)
				if scartype(target) == ST_ENTITY and Entity_GetSquad(target) then
					target = Entity_GetSquad(target)
					local ui_info = BP_GetSquadUIInfo(Squad_GetBlueprint(target), Player_GetRace(Squad_GetPlayerOwner(target)))
					Obj_SetTitle(obj.ID, ui_info.screenName)
					HintPoint_AddToSquad(target, 1, true, nothing, "PrimaryObjectiveDataTemplate", Loc_Empty(), true, World_Pos(0,2,0), -1, HPAT_Objective, "icons/objectives/objective_primary", true)
					FOW_RevealSquad(target, 2.0, 0.5)
				end
				return target
			end
			primary.targets[1] = _ReplaceEntityWithSquad(subobjective_1, primary.targets[1])
			primary.targets[2] = _ReplaceEntityWithSquad(subobjective_2, primary.targets[2])
			Objective_Start(subobjective_1, false, false)
			Objective_Start(subobjective_2, false, false)
			Objective_Start(bonus, true, false)
			Rule_AddOneShot(Skirmish_Flare, 30, nil, mission_rule)
			Rule_AddGlobalEvent(Skirmish_FixedDefendSquadKilled, GE_SquadKilled)
			Audio_TrackHealth({primary.targets}, ALL)
		end,
		IsComplete = function()
			local spawn_list = _fixed[_skirmish.company.enemy]
			for _, spawn_data in pairs(spawn_list) do
				if spawn_data[1] > 0 then
					return false
				end
			end
			return not SGroup_Exists("sg_attacker") or SGroup_CountSpawned(SGroup_FromName("sg_attacker")) <= 2
		end,
		OnComplete = function()
			UI_DeleteMinimapBlip(primary.blip) 
			Rule_RemoveGlobalEvent(Skirmish_FixedDefendSquadKilled)
			Core_CallDelegateFunctions("OnWinConditionTriggered", Skirmish_CreateMatchResult(local_player))
		end,
		Intel_Complete = function()
			AI_SetPrefabActive(subobjective_1.ai_prefab, enemy_player, false)
			AI_SetPrefabActive(subobjective_2.ai_prefab, enemy_player, false)
			if subobjective_1.ai_homing then
				AI_SetPrefabActive(subobjective_1.ai_homing, enemy_player, false)
			end
			if subobjective_2.ai_homing then
				AI_SetPrefabActive(subobjective_2.ai_homing, enemy_player, false)
			end
			_skirmish.match_result = Skirmish_CreateMatchResult(local_player, WR_NONE)
			Skirmish_Rout()
			CTRL.Subtitle_PlayNarrativeEvent(narrative.victory)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		IsFailed = function()
			return Objective_AreSubObjectivesFailed(primary, ALL)
		end,
		OnFail = function()
			Rule_RemoveGlobalEvent(Skirmish_FixedDefendSquadKilled)
			Core_CallDelegateFunctions("OnWinConditionTriggered", Skirmish_CreateMatchResult(enemy_player))
		end,
		Intel_Fail = function()
			_skirmish.match_result = Skirmish_CreateMatchResult(enemy_player, WR_NONE)
			Skirmish_Rout()
			CTRL.Subtitle_PlayNarrativeEvent(narrative.defeat)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		PreFail = Skirmish_FailBonusObjective,
		targets = targets,
	}
	subobjective_1 = {
		Title = _GetName(targets[1]),
		showTitle = false,
		Type = OT_Primary,
		Parent = primary,
		OnStart = function() 
			subobjective_1.blip = UI_CreateMinimapBlip(primary.targets[1], -1, "PrimaryObjectiveDataTemplate") 
		end,
		IsFailed = function() return not Util_IsAlive(primary.targets[1]) end,
		PreFail = function() Skirmish_FixedDefendTargetDestroyed(subobjective_1) end,
		OnFail = function() UI_DeleteMinimapBlip(subobjective_1.blip) end,
		pos = Util_GetPosition(targets[1]),
	}
	subobjective_2 = {
		Title =  _GetName(targets[2]),
		showTitle = false,
		Type = OT_Primary,
		Parent = primary,
		OnStart = function() 
			subobjective_2.blip = UI_CreateMinimapBlip(primary.targets[2], -1, "PrimaryObjectiveDataTemplate")
		end,
		IsFailed = function() return not Util_IsAlive(primary.targets[2]) end,
		PreFail = function() Skirmish_FixedDefendTargetDestroyed(subobjective_2) end,
		OnFail = function() UI_DeleteMinimapBlip(subobjective_2.blip) end,
		pos = Util_GetPosition(targets[2]),
	}
	bonus = {
		Title =  11220491,  -- Minimize casualties
		Type = OT_Bonus,
		OnStart = function()
			Skirmish_TrackManpower()
			Skirmish_UpdateLossRatio()
			Obj_SetProgressVisible(bonus.ID, true)
			Rule_AddGlobalEvent(Skirmish_TrackLosses, GE_EntityKilled)
			Rule_AddGlobalEvent(Skirmish_FixedOnSquadReinforced, GE_SquadProductionQueue)
		end,
		IsComplete = function()
			return primary.IsComplete() and bonus.manpower_loss_ratio >= bonus.fail_threshold
		end,
		IsFailed = function() 
			return bonus.manpower_loss_ratio < bonus.fail_threshold
		end,
		manpower_loss_ratio = 1.0,
		fail_threshold = Scale({0.2, 0.25, 0.3, 0.35, 0.4}),
	}
	Objective_Register(primary)
	Objective_Register(subobjective_1)
	Objective_Register(subobjective_2)
	Objective_Register(bonus)
	
	-- AI
	subobjective_1.ai_prefab = AI_AddPrefab(enemy_player, "attack_1", "Push", 30, 1, Scale(2,6, math.round), false, true)
	subobjective_2.ai_prefab = AI_AddPrefab(enemy_player, "attack_2", "Push", 30, 1, Scale(2,6, math.round), false, true)
	AI_SetPrefabTarget_Position(subobjective_1.ai_prefab, enemy_player, subobjective_1.pos)
	AI_SetPrefabTarget_Position(subobjective_2.ai_prefab, enemy_player, subobjective_2.pos)
end

-- Rule for spawn attacking enemy squads in waves/dribbles
function Skirmish_FixedDefendSpawnSquads(context, data)
	local spawn_count = Scale({2,2,3,3,4})
	local pos = Skirmish_GetMapEntryPosition(enemy_player)
	local spawn_list = _fixed[_skirmish.company.enemy]
	local sg = SGroup_CreateIfNotFound("sg_attacker")
	for _, spawn_data in pairs(spawn_list) do
		if spawn_data[1] > 0 then
			spawn_data[1] = spawn_data[1] - 1
			local upgrades = {}
			if spawn_data[3] then
				if spawn_data[4] then
					if World_GetRand(1,100) <= spawn_data[4] * 100 then
						table.insert(upgrades, BP_GetUpgradeBlueprint(spawn_data[3]))
					end
				else
					table.insert(upgrades, BP_GetUpgradeBlueprint(spawn_data[3]))
				end
			end

			local dest = Player_GetStartingPosition(local_player)
			for i = 1, 5 do
				local target = primary.targets[World_GetRand(1, #primary.targets)]
				if  Util_IsAlive(target) then
					dest = target
					break
				end
			end
			Util_CreateSquads(enemy_player, sg, spawn_data[2], pos, dest, 1, nil, true, nil, upgrades, Util_ScarPos(0,0))
			spawn_count = spawn_count - 1
			if spawn_count <= 0 then
				UI_CreateMinimapBlip(pos, 10.0, "attack_here")
				Skirmish_SetWeaponsDroppable(Player_GetSquads(enemy_player))
				break
			end
		end
	end
end


-- Returns the number of enemy squads remaining to spawn
function Skirmish_FixedDefendEnemyReinforcements()
	local squads_remaining = 0
	local spawn_list = _fixed[_skirmish.company.enemy]
	for _, spawn_data in pairs(spawn_list) do
		squads_remaining = squads_remaining + spawn_data[1]
	end
	return squads_remaining
end


-- Global event callback for GE_SquadKilled
function Skirmish_FixedDefendSquadKilled(context)
	-- AI attacker charges player if down to last few squads
	if not World_OwnsSquad(context.victim) 
		and Squad_GetPlayerOwner(context.victim) == enemy_player 
		and Skirmish_FixedDefendEnemyReinforcements() == 0 then
		local sg = Player_GetSquads(enemy_player)
		SGroup_FilterSpawned(sg, FILTER_KEEP)
		SGroup_Filter(sg, {"building", "artillery", "base_defense", "auto_builder", "airplane"}, FILTER_REMOVE)
		if SGroup_CountSpawned(sg) <= 4 then
			local _HomeOnObjective = function(obj)
				if Obj_GetState(obj.ID) == OS_Failed and not obj.ai_homing then
					AI_SetPrefabActive(obj.ai_prefab, enemy_player, false)
					obj.ai_homing = AI_AddPrefab(enemy_player, "homing_1", "Homing", 30, 1, 3, true, true)
					AI_SetPrefabTarget_Position(obj.ai_homing, enemy_player, obj.pos)
					print("AI is homing on remaining objective")
					return true
				end
			end
			if _HomeOnObjective(subobjective_1) or _HomeOnObjective(subobjective_2) then
				FOW_PlayerRevealAll(enemy_player)
			end
		end
	end

	-- Spawn off-map reinforcements for defending local player
	primary.remaining_reinforcements = primary.remaining_reinforcements or 3
	Skirmish_QueueReinforcement(context.victim)
end


function Skirmish_FixedDefendTargetDestroyed(subobjective)
	AI_SetPrefabActive(subobjective.ai_prefab, enemy_player, false)
end

-----------------------------------------------------------------------
-- Fixed Force (attack)
-----------------------------------------------------------------------

function Skirmish_InitModeFixedForceAttack(attacker, defender, narrative)
	Skirmish_RemoveVictoryPoints()
	Skirmish_HideTerritoryPoints(defender)
	Core_UnregisterModule("DestroyHQ")
	Core_UnregisterModule("Tickets")
	Core_UnregisterModule("Territory")
	Core_UnregisterModule("EntityLoss")
	Core_UnregisterModule("VictoryPoint")
	
	TicketUI_SetVisibility(false, false, false)

	Rule_AddInterval(Skirmish_UpdateTerritory, 10, nil, mission_rule)

	local _RemoveDefaultStuff = function(player, exclusions)
		local eg = Player_GetEntities(player)
		for i = 1, #exclusions do
			if scartype(exclusions[i]) == ST_STRING then
				exclusions[i] = BP_GetEntityBlueprint(exclusions[i])
			end
		end
		EGroup_Filter(eg, exclusions, FILTER_REMOVE)
		EGroup_DeSpawn(eg)
		SGroup_DeSpawn(Player_GetSquads(player))
	end
	_RemoveDefaultStuff(attacker, {"starting_territory_team", "map_entry_point", "map_entry_point_player", "starting_position", "starting_position_no_hq", "retreat_point" })
	_RemoveDefaultStuff(defender, {"starting_territory_team", "map_entry_point", "map_entry_point_player", "starting_position", "starting_position_no_hq", "retreat_point", "territory_creator_invisible" })

	-- Initial engagement location
	local mkr_rally = Skirmish_GetMarkers("mkr_rally", attacker)
	Camera_MoveTo(Marker_GetPosition(mkr_rally), nil, nil, nil, true)
	Camera_SetInputEnabled(false)

	-- Spawn objectives (bunkers, etc.)
	local markers=  {}
	local m = Skirmish_GetMarkers("mkr_bunker", defender, true)
	table.insert(markers, m[World_GetRand(1, #m/2)])
	table.insert(markers, m[World_GetRand(1 + #m/2, #m)])
	m = Skirmish_GetMarkers("mkr_bunker_rear", defender, true)
	table.insert(markers, m[World_GetRand(1, #m)])

	local targets = {}
	local target_list = {
		germans = {
			SBP.GERMAN.HMG_MG42_BUNKER_GER,
			SBP.GERMAN.HMG_MG42_BUNKER_GER,
			SBP.GERMAN.HMG_MG42_BUNKER_GER,
			SBP.GERMAN.AT_GUN_88MM_EMPLACEMENT_GER,
			SBP.GERMAN.AT_GUN_88MM_EMPLACEMENT_GER,
			SBP.GERMAN.AT_GUN_88MM_EMPLACEMENT_GER,
		},
	}
	target_list = Table_GetRand(target_list[Player_GetRaceName(defender)], #markers)

	local _SpawnTargetAt = function(bp, marker)
		local facing = Util_GetOffsetPosition(marker, OFFSET_FRONT, 10)
		if SBP_Exists(BP_GetName(bp)) then
			local sg = SGroup_CreateUnique()
			Util_CreateSquads(defender, sg, bp, marker, marker, 1, nil, false, nil, upgrades, facing)
			table.insert(targets, SGroup_GetSquadAt(sg, 1))

			-- Buff objective targets
			SGroup_ForEach(sg,  function(sgroup, index, squad)
					local modifier = Modifier_Create(MAT_Entity, "health_maximum_modifier", MUT_Multiplication, false, 2.0, "")
					for i = 1, Squad_Count(squad) do
						local entity = Squad_EntityAt(squad, i-1)
						if Entity_ExtensionExist(entity, "modifier_ext") and Entity_IsActive(entity) then
							Modifier_ApplyToEntity(modifier, entity, 0)
						end
					end
					Squad_SetRecrewable(squad, false)
					if bp == SBP.GERMAN.AT_GUN_88MM_EMPLACEMENT_GER then
						--Cmd_Ability(sg, BP_GetAbilityBlueprint("prioritize_vehicles"), sg)		--BUG: Does not work
						--HACK: Workaround for inability to toggle "prioritize_vehicles" off on Flak 36
						Player_SetAbilityAvailability(defender, BP_GetAbilityBlueprint("prioritize_vehicles"), ITEM_REMOVED)
					end
				end)
			SGroup_Destroy(sg)
		else
			local eg = EGroup_CreateUnique()
			Util_CreateEntities(defender, eg, bp, marker, 1, facing, true, false, true)
			table.insert(targets, EGroup_GetEntityAt(eg, 1))
			EGroup_Destroy(eg)
		end

		-- Spawn munition and medical crates
		local _SpawnCrate = function(ebp, pos)
			local entity = Entity_CreateENVFacing(ebp, pos, Prox_GetRandomPosition(pos, 10, 10), true)
			Entity_SetPosition(entity, Entity_CalculatePassableSpawnPosition(entity, pos))
			Entity_Spawn(entity)
		end
		local offsets = { {OFFSET_BACK_LEFT, OFFSET_BACK }, {OFFSET_BACK_RIGHT, OFFSET_BACK }, {OFFSET_BACK_RIGHT, OFFSET_BACK_LEFT },}
		local offset = offsets[World_GetRand(1, #offsets)]
		local pos = Util_GetPosition(targets[#targets])
		_SpawnCrate(EBP.AMERICAN.MUNITION_PARADROP_US, Util_GetOffsetPosition(pos, offset[1], 6 + World_GetRand(1,20)/10))
		--_SpawnCrate(EBP.AMERICAN.MEDICAL_CRATE_US, Util_GetOffsetPosition(pos, offset[2], 6 + World_GetRand(1,20)/10))
	end

	for i, marker in pairs(markers) do
		_SpawnTargetAt(target_list[i], marker)
	end

	-- Disable resource income
	for i = 1, World_GetPlayerCount() do 
		local player = World_GetPlayerAt(i)
		Player_CompleteUpgrade(player, BP_GetUpgradeBlueprint("disable_passive_resource_income"))
	end

	-- Initial resources and income
	Anvil_SetPlayerResources(local_player, 0, 0, 0)
	local player_munitions = Scale({400, 350, 300, 250, 200, 150, 100, 50, 0})
	Skirmish_InitStartingResources(local_player, { 0, 0, 600, player_munitions }, true)	-- action?, fuel, manpower, munition
	Skirmish_InitStartingResources(enemy_player, { 0, 0, 600, 400 }, true)
	Skirmish_InitStartingResources(unused_player,{ 0, 0, 400, 300 }, true)
	
	-- Enemy behaviour
	AI_SetPersonality(enemy_player, "mission_ai_personality.xml")
	AI_Enable(unused_player, true)	-- Allow enemy's ally to use battlegroup abilities

	-- Retreat points
	local _CreateEntity = function (ebp, position, owner)
		local pos = Entity_FindConstructionLocation(owner, ebp, position, 15, 1)
		local entity = Entity_CreateFacing(ebp, owner, pos, Util_ScarPos(0,0), true)
		Entity_Spawn(entity)
		Entity_ForceConstruct(entity)
		World_UpdatePathfindingBlockers()
	end
	_CreateEntity(BP_GetEntityBlueprint("retreat_point"), Util_GetPosition(targets[#targets]), defender)
	--_CreateEntity(BP_GetEntityBlueprint("retreat_point"), Player_GetStartingPosition(attacker), attacker)
	if Player_GetRace(attacker) == RACE.BRITISH then
		_CreateEntity(EBP.BRITISH.RALLY_POINT_UK, Util_GetPosition(Skirmish_GetMarkers("mkr_base", attacker)), attacker)
	else
		_CreateEntity(EBP.AMERICAN.RALLY_POINT_US, Util_GetPosition(Skirmish_GetMarkers("mkr_base", attacker)), attacker)
	end

	-- Spawn units
	local diff_scale = Scale({0.2, 0.3, 0.4, 0.6, 0.8})
	_fixed = {
		company_infantry_us = {
			{1, SBP.AMERICAN.HALFTRACK_US, "medical_halftrack_us" },
			{1, SBP.AMERICAN.ENGINEER_US, "flamethrower_engineer_us" },
			{1, SBP.AMERICAN.ENGINEER_US, },
			{1, SBP.AMERICAN.RIFLEMEN_US, "bar_rifleman_squad_us" },
			{2, SBP.AMERICAN.BAZOOKA_TEAM_US, },
			{1, SBP.AMERICAN.SCOUT_US, },
			{1, SBP.AMERICAN.CHAFFEE_US,  },
			{1, SBP.AMERICAN.AT_GUN_57MM_US, },
			--{1, SBP.AMERICAN.GREYHOUND_US, },
		},
		company_paratrooper_us = {
			{1, SBP.AMERICAN.HALFTRACK_US, "medical_halftrack_us" },
			{1, SBP.AMERICAN.ENGINEER_US, "flamethrower_engineer_us" },
			{1, SBP.AMERICAN.ENGINEER_US, },
			{1, SBP.AMERICAN.RIFLEMEN_US, "bar_rifleman_squad_us" },
			{1, SBP.AMERICAN.PARATROOPER_US, "bazooka_paratrooper_us", },
			{1, SBP.AMERICAN.PARATROOPER_US, },
			{1, SBP.AMERICAN.PATHFINDER_US},
			{1, SBP.AMERICAN.CHAFFEE_US,},
		},
		company_spec_ops_us = {
			{1, SBP.AMERICAN.HALFTRACK_US, "medical_halftrack_us" },
			{1, SBP.AMERICAN.ENGINEER_US, "flamethrower_engineer_us" },
			{1, SBP.AMERICAN.ENGINEER_US, },
			{1, SBP.AMERICAN.RIFLEMEN_US, "bar_rifleman_squad_us" },
			{1, SBP.AMERICAN.SSF_COMMANDOS_US, },
			{1, SBP.AMERICAN.SCOUT_US, },
			{1, SBP.AMERICAN.CHAFFEE_US,  },
			{1, SBP.AMERICAN.AT_GUN_57MM_US, },
			{1, SBP.AMERICAN.GREYHOUND_US, },
		},
		company_armoured_us = {
			{1, SBP.AMERICAN.HALFTRACK_US, "medical_halftrack_us" },
			{1, SBP.AMERICAN.ASSAULT_ENGINEER_US, "flamethrower_engineer_us" },
			{1, SBP.AMERICAN.ASSAULT_ENGINEER_US, },
			{1, SBP.AMERICAN.RIFLEMEN_US, "bar_rifleman_squad_us" },
			{1, SBP.AMERICAN.BAZOOKA_TEAM_US, },
			{1, SBP.AMERICAN.SCOUT_US, },
			{1, SBP.AMERICAN.SHERMAN_US,  },
			--{1, SBP.AMERICAN.AT_GUN_57MM_US, },
			{1, SBP.AMERICAN.CHAFFEE_US, },
		},
		company_airborne_uk = {
			{1, SBP.BRITISH.CWT_15_TRUCK_UK, "medical_truck_uk" },
			{1, SBP.BRITISH.SAPPER_UK, "flamethrower_sapper_uk" },
			{1, SBP.BRITISH.SAPPER_UK, },
			{1, SBP.BRITISH.TOMMY_UK, "lmg_bren_tommy_uk" },
			{1, SBP.BRITISH.TOMMY_UK, "boys_anti_tank_rifles_tommy_uk" },
			{2, SBP.BRITISH.GUARDS_UK, },
			{1, SBP.BRITISH.VALENTINE_UK, },
			--{1, SBP.BRITISH.STUART_UK, },
			--{1, SBP.BRITISH.HUMBER_UK, },
			--{1, SBP.BRITISH.GRANT_UK, },
			--{1, SBP.BRITISH.MATILDA_UK, },
			--{1, SBP.BRITISH.SHERMAN_UK, },
			--{1, SBP.BRITISH.AT_GUN_6PDR_UK, },
			{1, SBP.BRITISH.HALFTRACK_M3_UK, },
		},
		company_artillery_uk = {
			{1, SBP.BRITISH.CWT_15_TRUCK_UK, "medical_truck_uk" },
			{1, SBP.BRITISH.SAPPER_UK, "flamethrower_sapper_uk" },
			{1, SBP.BRITISH.SAPPER_UK,},
			{1, SBP.BRITISH.TOMMY_UK, "lmg_bren_tommy_uk" },
			{1, SBP.BRITISH.TOMMY_UK, "boys_anti_tank_rifles_tommy_uk" },
			{1, SBP.BRITISH.GUARDS_UK, },
			{1, SBP.BRITISH.VALENTINE_UK, },
			--{1, SBP.BRITISH.STUART_UK, },
			--{1, SBP.BRITISH.HUMBER_UK, },
			--{1, SBP.BRITISH.GRANT_UK, },
			--{1, SBP.BRITISH.MATILDA_UK, },
			--{1, SBP.BRITISH.SHERMAN_UK, },
			{1, SBP.BRITISH.AT_GUN_6PDR_UK, },
			{1, SBP.BRITISH.HALFTRACK_M3_UK, },
		},
		company_armoured_uk = {
			{1, SBP.BRITISH.CWT_15_TRUCK_UK, "medical_truck_uk" },
			{1, SBP.BRITISH.SAPPER_UK, "flamethrower_sapper_uk" },
			{1, SBP.BRITISH.SAPPER_UK,  },
			{1, SBP.BRITISH.TOMMY_UK, "boys_anti_tank_rifles_tommy_uk" },
			{1, SBP.BRITISH.GUARDS_UK, },
			--{1, SBP.BRITISH.VALENTINE_UK, },
			{2, SBP.BRITISH.SHERMAN_UK, },
			--{1, SBP.BRITISH.STUART_UK, },
			{1, SBP.BRITISH.HUMBER_UK, },
			--{1, SBP.BRITISH.GRANT_UK, },
			--{1, SBP.BRITISH.MATILDA_UK, },
			--{1, SBP.BRITISH.SHERMAN_UK, },
			--{1, SBP.BRITISH.AT_GUN_6PDR_UK, },
			--{1, SBP.BRITISH.HALFTRACK_M3_UK, },
		},
		company_infantry_ger = {
			{3, SBP.GERMAN.JAEGER_GER, "g43_jaeger_ger", diff_scale },
			{2, SBP.GERMAN.JAEGER_GER, "panzerschrek_jaeger_ger", diff_scale },
			{3, SBP.GERMAN.PIONEER_GER, "flamethrower_pioneer_ger", diff_scale },
			{1, SBP.GERMAN.AT_GUN_LG40_GER },
			{1, SBP.GERMAN.MORTAR_81MM_GER, },
			{2, SBP.GERMAN.ARMORED_CAR_GER, "20mm_panzerbuchse_armored_car_ger", diff_scale},
			{1, SBP.GERMAN.HALFTRACK_STUMMEL_GER, },
			{1, SBP.GERMAN.WESPE_GER, },
			{1, SBP.GERMAN.PANZER_IV_CMD_GER, },
			{2, SBP.GERMAN.STUG_III_GER, "mg42_stug_ger", diff_scale },
		},
		company_luftwaffe_ger = {
			{2, SBP.GERMAN.JAEGER_GER, "panzerschrek_jaeger_ger", diff_scale },
			{2, SBP.GERMAN.FALLSCHIRMPIONEERS_GER, "g43_jaeger_ger", diff_scale },
			{2, SBP.GERMAN.FALLSCHIRMPIONEERS_GER, "grb_39_grenade_launcher_fallschirmpioneer_ger", diff_scale },
			{1, SBP.GERMAN.FALLSCHIRMJAGERS_GER },
			{1, SBP.GERMAN.MORTAR_81MM_GER, },
			{1, SBP.GERMAN.WIRBELWIND_GER, },
			{2, SBP.GERMAN.STUG_III_GER, "mg42_stug_ger", diff_scale },
			{2, SBP.GERMAN.PANZER_IV_GER, "mg42_panzer_ger", diff_scale },
		},
		company_mechanized_ger = {
			{3, SBP.GERMAN.PANZERGRENADIER_GER },
			{2, SBP.GERMAN.JAEGER_GER, "panzerschrek_jaeger_ger", diff_scale },
			{3, SBP.GERMAN.PIONEER_GER, "flamethrower_pioneer_ger", diff_scale },
			{1, SBP.GERMAN.MORTAR_81MM_GER, },
			{1, SBP.GERMAN.ARMORED_CAR_GER, "20mm_panzerbuchse_armored_car_ger", diff_scale},
			{1, SBP.GERMAN.HALFTRACK_STUMMEL_GER, },
			{1, SBP.GERMAN.WESPE_GER, },
			{2, SBP.GERMAN.PANZER_IV_GER, "mg42_panzer_ger", diff_scale },
			{1, SBP.GERMAN.STUG_III_GER, "mg42_stug_ger", diff_scale },
		},
		company_armored_ger = {
			{3, SBP.GERMAN.PANZERGRENADIER_GER },
			{2, SBP.GERMAN.JAEGER_GER, "panzerschrek_jaeger_ger", diff_scale },
			{3, SBP.GERMAN.PIONEER_GER, "flamethrower_pioneer_ger", diff_scale },
			{1, SBP.GERMAN.MORTAR_81MM_GER, },
			{2, SBP.GERMAN.STUG_III_GER, "mg42_stug_ger", diff_scale },
			{2, SBP.GERMAN.PANZER_IV_GER, "mg42_panzer_ger", diff_scale },
			{1, SBP.GERMAN.PANTHER_GER, },
		},
	}

	-- Spawn attacking/defending squads
	local _SpawnSquads = function(spawn_list, player, sg, markers)
		local m = 0
		for _, spawn_data in pairs(spawn_list) do
			for i = 1, spawn_data[1] do 
				local upgrades = {}
				if spawn_data[3] then
					if spawn_data[4] then
						if World_GetRand(1,100) <= spawn_data[4] * 100 then
							table.insert(upgrades, BP_GetUpgradeBlueprint(spawn_data[3]))
						end
					else
						table.insert(upgrades, BP_GetUpgradeBlueprint(spawn_data[3]))
					end
				end
				m = (m % #markers)+1
				local marker = markers[m]
				local pos = Prox_GetRandomPosition(marker, 20, 12)
				-- Ensure spawn position is inside interactive zone
				while World_GetInteractionStageAtPoint(pos) ~= 0 do
					pos = Prox_GetRandomPosition(marker, 20, 12)
				end
				local facing = Util_GetOffsetPosition(marker, OFFSET_FRONT, 80)
				Util_CreateSquads(player, sg, spawn_data[2], pos, dest, nil, nil, false, nil, upgrades, facing)
			end
		end
	end
	Sound_Play2D("mix_mute_speech_on")
	_SpawnSquads(_fixed[_skirmish.company.player], attacker, SGroup_CreateIfNotFound("sg_attacker"), {Skirmish_GetMarkers("mkr_base", attacker, false)})
	_SpawnSquads(_fixed[_skirmish.company.enemy], defender, SGroup_CreateIfNotFound("sg_defender"), targets)
	
	Skirmish_SetWeaponsDroppable(Player_GetSquads(attacker))
	Skirmish_SetWeaponsDroppable(Player_GetSquads(defender))
	
	local health = Scale({50, 60, 70, 80, 90, 100, 100, 100})
	
	if health ~= 100 then
		local setHealth = function(gid, idx, squad)
			Squad_SetHealth(squad, math.min(1.0, World_GetRand(health - 15, health + 15) / 100))
		end
		SGroup_ForEach(SGroup_FromName("sg_defender"), setHealth)
	end
	
	-- Prevent artillery cheese
	--SGroup_SetTeamWeaponCapturable(Player_GetSquads(enemy_player), false)
	--SGroup_ForEach(Player_GetSquads(enemy_player), function(sgroup, index, squad)
			--Squad_SetTeamWeaponDestroyOnAbandonChance(squad, 1.0)
		--end)
	
	--TODO: Spawn attackers differently - have them arrive in convoy/on the march, tank desant
	--TODO: Garrison nearby squad in bunker or halftrack? Have halftrack to AT gun
	-- Cmd_Garrison(sg_util_temp, location, true, true, true)
	
	-- Move attacker's squads to rally point
	local sg = SGroup_CreateUnique()
	local start = Player_GetStartingPosition(attacker)
	local dest = Marker_GetPosition(mkr_rally)
	SGroup_ForEach(Player_GetSquads(attacker), function(sgroup, index, squad)
			--Misc_SetSquadSelectable()
			local pos = Squad_GetPosition(squad)
			pos.x = pos.x + (dest.x - start.x)
			pos.z = pos.z + (dest.z - start.z)
			SGroup_Clear(sg)
			SGroup_Add(sg, squad)
			Cmd_Move(sg, pos)
		end)
	SGroup_Destroy(sg)
	
	Affectors_SpawnReinforcements(defender)
	Rule_AddOneShot(Skirmish_SpawnReinforcements, 25.0, {player = attacker, destination = dest}, mission_rule)
	
	--Spawn lone enemy patrol
	--World_EnableSharedLineOfSight(enemy_player, unused_player, false)
	--local dest = Marker_GetPosition(mkr_rally)
	--local pos = World_GetOffsetPosition(Marker_GetPosition(mkr_rally), Marker_GetDirection(mkr_rally), OFFSET_FRONT, 30)
	--Util_CreateSquads(unused_player, nil, SBP.GERMAN.GRENADIER_GER, pos, dest, 1, 0, true)

	local _GetName = function(thing)
		if scartype(thing) == ST_SQUAD then
			local ui_info = BP_GetSquadUIInfo(Squad_GetBlueprint(thing), Player_GetRace(Squad_GetPlayerOwner(thing)))
			return ui_info.screenName
		elseif scartype(thing) == ST_ENTITY then
			local ui_info = BP_GetEntityUIInfo(Entity_GetBlueprint(thing))
			return ui_info.screenName
		end
	end
	
	primary = {
		Title = narrative.obj_text,
		showTitle = true,
		Type = OT_Primary,
		Intel_Start = function()
			CTRL.Event_Delay(3)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(narrative.intro1)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(narrative.intro2)
			CTRL.WAIT()
		end,
		OnStart = function()
			Sound_Play2D ("mix_mute_speech_off")
			Camera_SetInputEnabled(true)
			-- Update subobjective titles and targets with names of squads (bunkers are weird...)
			local _ReplaceEntityWithSquad = function(obj, target)
				if scartype(target) == ST_ENTITY and Entity_GetSquad(target) then
					target = Entity_GetSquad(target)
					local ui_info = BP_GetSquadUIInfo(Squad_GetBlueprint(target), Player_GetRace(Squad_GetPlayerOwner(target)))
					Obj_SetTitle(obj.ID, ui_info.screenName)
					HintPoint_AddToSquad(target, 1, true, nothing, "PrimaryObjectiveDataTemplate", Loc_Empty(), true, World_Pos(0,2,0), -1, HPAT_Objective, "icons/objectives/objective_primary", true)
					FOW_RevealSquad(target, 2.0, 0.5)
				end
				return target
			end
			primary.targets[1] = _ReplaceEntityWithSquad(subobjective_1, primary.targets[1])
			primary.targets[2] = _ReplaceEntityWithSquad(subobjective_2, primary.targets[2])
			primary.targets[3] = _ReplaceEntityWithSquad(subobjective_3, primary.targets[3])
			Objective_Start(subobjective_1, false, false)
			Objective_Start(subobjective_2, false, false)
			Objective_Start(subobjective_3, false, false)
			Objective_Start(bonus, true, false)
			Rule_AddOneShot(Skirmish_Flare, 20, nil, mission_rule)
			Rule_AddGlobalEvent(Skirmish_FixedAttackSquadKilled, GE_SquadKilled)
			Audio_TrackHealth({primary.targets}, ALL)
		end,
		IsComplete = function()
			return Objective_AreSubObjectivesComplete(primary, ALL)
		end,
		OnComplete = function()
			Rule_RemoveGlobalEvent(Skirmish_FixedAttackSquadKilled)
			Core_CallDelegateFunctions("OnWinConditionTriggered", Skirmish_CreateMatchResult(local_player))
		end,
		Intel_Complete = function()
			_skirmish.match_result = Skirmish_CreateMatchResult(local_player, WR_NONE)
			Skirmish_Rout()
			CTRL.Subtitle_PlayNarrativeEvent(primary.narrative.victory)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		IsFailed = function()
			local sg = Player_GetSquads(local_player)
			SGroup_Filter(sg, {"building", "base_defense", "auto_builder", "airplane"}, FILTER_REMOVE)
			return SGroup_CountSpawned(sg) <= 0
		end,
		OnFail = function()
			Rule_RemoveGlobalEvent(Skirmish_FixedAttackSquadKilled)
			Core_CallDelegateFunctions("OnWinConditionTriggered", Skirmish_CreateMatchResult(enemy_player))
		end,
		Intel_Fail = function()
			_skirmish.match_result = Skirmish_CreateMatchResult(enemy_player, WR_NONE)
			Skirmish_Rout()
			CTRL.Subtitle_PlayNarrativeEvent(primary.narrative.defeat)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		PreFail = Skirmish_FailBonusObjective,
		targets = targets,
		attacker = attacker,
		defender = defender,
		narrative = narrative,
	}
	subobjective_1 = {
		Title = _GetName(targets[1]),
		showTitle = false,
		Type = OT_Primary,
		Parent = primary,
		OnStart = function() 
			subobjective_1.blip = UI_CreateMinimapBlip(primary.targets[1], -1, "PrimaryObjectiveDataTemplate") 
			UI_CreateMinimapBlip(primary.targets[1], 10.0, "attack_here")
		end,
		IsComplete = function() return primary.attacker == local_player and not Util_IsAlive(primary.targets[1]) end,
		IsFailed = function() return primary.defender == local_player and not Util_IsAlive(primary.targets[1]) end,
		PreComplete = function() Skirmish_FixedAttackTargetDestroyed(subobjective_1) end,
		OnComplete = function() UI_DeleteMinimapBlip(subobjective_1.blip) end,
		reward = 100, -- manpower reward
		pos = Util_GetPosition(targets[1]),
	}
	subobjective_2 = {
		Title =  _GetName(targets[2]),
		showTitle = false,
		Type = OT_Primary,
		Parent = primary,
		OnStart = function() 
			subobjective_2.blip = UI_CreateMinimapBlip(primary.targets[2], -1, "PrimaryObjectiveDataTemplate")
			UI_CreateMinimapBlip(primary.targets[2], 10.0, "attack_here")
		end,
		IsComplete = function() return not Util_IsAlive(primary.targets[2]) end,
		PreComplete = function() Skirmish_FixedAttackTargetDestroyed(subobjective_2) end,
		OnComplete = function() UI_DeleteMinimapBlip(subobjective_2.blip) end,
		reward = 100, -- manpower reward
		pos = Util_GetPosition(targets[2]),
	}
	subobjective_3 = {
		Title =  _GetName(targets[3]),
		Type = OT_Primary,
		Parent = primary,
		OnStart = function() 
			subobjective_3.blip = UI_CreateMinimapBlip(primary.targets[3], -1, "PrimaryObjectiveDataTemplate")
			UI_CreateMinimapBlip(primary.targets[3], 10.0, "attack_here")
		end,
		IsComplete = function() return not Util_IsAlive(primary.targets[3]) end,
		PreComplete = function() Skirmish_FixedAttackTargetDestroyed(subobjective_3) end,
		OnComplete = function() UI_DeleteMinimapBlip(subobjective_3.blip) end,
		reward = 100, -- manpower reward
		pos = Util_GetPosition(targets[3]),
	}
	bonus = {
		Title =  11220491,  -- Minimize casualties
		Type = OT_Bonus,
		--Parent = primary,
		OnStart = function()
			Skirmish_TrackManpower()
			Skirmish_UpdateLossRatio()
			Obj_SetProgressVisible(bonus.ID, true)
			Rule_AddGlobalEvent(Skirmish_TrackLosses, GE_EntityKilled)
			Rule_AddGlobalEvent(Skirmish_FixedOnSquadReinforced, GE_SquadProductionQueue)
		end,
		IsComplete = function()
			return primary.IsComplete() and bonus.manpower_loss_ratio >= bonus.fail_threshold
		end,
		IsFailed = function() 
			return bonus.manpower_loss_ratio < bonus.fail_threshold
		end,
		manpower_loss_ratio = 1.0,
		fail_threshold = Scale({0.2, 0.25, 0.3, 0.35, 0.4}),
	}
	Objective_Register(primary)
	Objective_Register(subobjective_1)
	Objective_Register(subobjective_2)
	Objective_Register(subobjective_3)
	Objective_Register(bonus)
	
	-- AI
	subobjective_1.ai_prefab = AI_AddPrefab(enemy_player, "defend_1", "Defend", 30, 1, 5, false, true)
	subobjective_2.ai_prefab = AI_AddPrefab(enemy_player, "defend_2", "Defend", 30, 1, 5, false, true)
	subobjective_3.ai_prefab = AI_AddPrefab(enemy_player, "defend_3", "Defend", 30, 1, 5, false, true)
	AI_SetPrefabTarget_Position(subobjective_1.ai_prefab, enemy_player, subobjective_1.pos)
	AI_SetPrefabTarget_Position(subobjective_2.ai_prefab, enemy_player, subobjective_2.pos)
	AI_SetPrefabTarget_Position(subobjective_3.ai_prefab, enemy_player, subobjective_3.pos)
end


function Skirmish_FixedAttackTargetDestroyed(subobjective)
	AI_SetPrefabActive(subobjective.ai_prefab, enemy_player, false)
	Player_AddResource(local_player, RT_Manpower, subobjective.reward)
	
	-- Show notification only if at least one target remains
	for _, target in pairs(primary.targets) do
		if Item_IsAlive(target) then
			UI_CreateEventCue(Loc_FormatText(11169594, subobjective.reward), -- "+X Manpopwer"
				Loc_Empty(), 
				"low_priority",
				"icons/common/resources/resource_small_manpower",
				"",
				ECV_Queue,
				10.0)
			break
		end
	end
	--bonus.manpower_total = bonus.manpower_total + subobjective.reward
end


function Skirmish_UpdateLossRatio()
	if Obj_GetState(bonus.ID) ~= OS_Complete and Obj_GetState(bonus.ID) ~= OS_Failed then
		bonus.manpower_lost = bonus.manpower_lost or 0
		bonus.manpower_loss_ratio = math.max(0.0, math.min(1.0, 1.0 - bonus.manpower_lost / bonus.manpower_total))
		local progress = math.max(0.0, math.min(1.0, 1.0 - bonus.manpower_lost / (bonus.manpower_total * (1.0 - bonus.fail_threshold))))
		Obj_SetProgress(bonus.ID, progress)
	end
end


-- Global event callback for GE_SquadProductionQueue
-- Adds manpower cost of entity to manpower_total
function Skirmish_FixedOnSquadReinforced(context)
	if not World_OwnsSquad(context.squad) and Squad_GetPlayerOwner(context.squad) == local_player then
		--print(">>> " ..BP_GetName(Squad_GetBlueprint(context.squad)) .." reinforced")
		local cost = Player_GetEntityBPCost(local_player, Entity_GetBlueprint(Squad_EntityAt(context.squad, 0)))
		bonus.manpower_total = math.floor(bonus.manpower_total + cost.manpower )
		Skirmish_UpdateLossRatio()
	end
end

function Skirmish_TrackSquadManpower(sgroup, index, squad)
	bonus.manpower_squads = bonus.manpower_squads or {}
	if not Table_Contains(bonus.manpower_squads, Squad_GetID(squad)) then
		table.insert(bonus.manpower_squads, Squad_GetID(squad))
		local cost = Player_GetSquadBPCost(local_player, Squad_GetBlueprint(squad))
		bonus.manpower_total = math.floor(bonus.manpower_total + cost.manpower)
	end
end

function Skirmish_TrackManpower()
	bonus.manpower_total = bonus.manpower_total or 0
	--bonus.manpower_total = bonus.manpower_total or Player_GetResource(local_player, RT_Manpower)
	local sg = Player_GetSquads(local_player)
	SGroup_FilterSpawned(sg, FILTER_KEEP)
	SGroup_Filter(sg, {"building", "base_defense", "auto_builder", "airplane"}, FILTER_REMOVE)
	SGroup_ForEach(sg, Skirmish_TrackSquadManpower)
end

-- Global event callback for GE_EntityKilled
function Skirmish_TrackLosses(context)
	if context.victim and context.victimOwner and context.victimOwner == local_player then
		if context.victimSquad and not (Squad_IsOfType(context.victimSquad, "airplane") or Squad_IsOfType(context.victimSquad, "building")) then
			Skirmish_TrackSquadManpower(nil, nil, context.victimSquad)
			local cost = Player_GetEntityBPCost(local_player, Entity_GetBlueprint(context.victim))
			bonus.manpower_lost = (bonus.manpower_lost or 0) + math.floor(cost.manpower)
			Skirmish_UpdateLossRatio()
		end
	end
end


-- Global event callback for GE_SquadKilled
function Skirmish_FixedAttackSquadKilled(context)
	-- AI charges player if down to last few squads
	if not World_OwnsSquad(context.victim) and Squad_GetPlayerOwner(context.victim) == enemy_player and not primary.ai_homing then
		local sg = Player_GetSquads(enemy_player)
		SGroup_FilterSpawned(sg, FILTER_KEEP)
		SGroup_Filter(sg, {"building", "artillery", "base_defense", "auto_builder", "airplane"}, FILTER_REMOVE)
		if SGroup_CountSpawned(sg) <= 4 then
			local pos = subobjective_1.pos
			if Obj_GetState(subobjective_1.ID) == OS_Complete then
				pos = subobjective_2.pos
				if Obj_GetState(subobjective_2.ID) == OS_Complete then
					pos = subobjective_3.pos
				end
			end
			FOW_PlayerRevealAll(enemy_player)
			AI_SetPrefabActive(subobjective_1.ai_prefab, enemy_player, false)
			AI_SetPrefabActive(subobjective_2.ai_prefab, enemy_player, false)
			AI_SetPrefabActive(subobjective_3.ai_prefab, enemy_player, false)
			primary.ai_homing = AI_AddPrefab(enemy_player, "homing_1", "Homing", 30, 1, 6, true, true)
			AI_SetPrefabTarget_Position(primary.ai_homing, enemy_player, pos)
		end
	end

	-- Spawn off-map reinforcements 
	primary.remaining_reinforcements = primary.remaining_reinforcements or 2
	Skirmish_QueueReinforcement(context.victim)
end


function Skirmish_QueueReinforcement(squad)
	if primary.remaining_reinforcements and primary.remaining_reinforcements > 0 and 
		squad and not World_OwnsSquad(squad) and Squad_GetPlayerOwner(squad) == local_player
		and not Squad_IsOfType(squad, "building")
		and not Squad_IsOfType(squad, "emplacement")
		and not Squad_IsOfType(squad, "airplane")
		and not Squad_IsCasualty(squad)
		and Squad_GetBlueprint(squad) ~= BP_GetSquadBlueprint("casualty") then
		primary.reinforcements = primary.reinforcements or {}
		local reinforcement = {
			Squad_GetBlueprint(squad),
			-- Squad_GetActiveUpgrades(context.victim) 	--TODO: system of tracking upgrades
		}
		table.insert(primary.reinforcements, reinforcement)
		if not Rule_Exists(Skirmish_FixedDelayedReinforce) then
			Rule_AddOneShot(Skirmish_FixedDelayedReinforce, 10, nil, mission_rule)
		end
	end
end


function Skirmish_FixedDelayedReinforce(context)
	if  primary.IsComplete() or primary.remaining_reinforcements <= 0 then
		return
	end
	for _, reinforcement in pairs(primary.reinforcements) do 
		if primary.remaining_reinforcements > 0 then
			local sg = SGroup_CreateUnique()
			local sbp = reinforcement[1]
			local upgrades = reinforcement[2]
			if scartype(upgrades) == ST_STRING then
				upgrades = BP_GetUpgradeBlueprint(upgrades)
			end
			local pos = Skirmish_GetMapEntryPosition(local_player)
			local dest = Marker_GetPosition(Skirmish_GetMarkers("mkr_rally", local_player))
			Util_CreateSquads(local_player, sg, sbp, pos, dest, nil, nil, false, nil, upgrades, Util_ScarPos(0,0))
			local ui_info = BP_GetSquadUIInfo(sbp, Player_GetRace(local_player))
			--local icon = string.gsub(ui_info.symbolIconName, "\\" , "/" )
			EventCue_Create("$11169599", "low_priority", SGroup_GetSquadAt(sg, 1), ui_info.symbolIconName, "", blip_template)	-- "Reinforcements incoming"
			SGroup_Destroy(sg)
			primary.remaining_reinforcements = primary.remaining_reinforcements - 1
			
			Player_AddResource(local_player, RT_Manpower, 100)
			UI_CreateEventCue(Loc_FormatText("$11169594", 100), Loc_Empty(), "low_priority",  "icons/common/resources/resource_small_manpower", "", ECV_Queue, 10.0)	-- "+X Manpopwer"
			--bonus.manpower_total = bonus.manpower_total + subobjective.reward
		end
	end
	primary.reinforcements = nil
	local intel = "skirmish_fixed_reinforcements_2"
	if primary.remaining_reinforcements < 1 then
		intel = "skirmish_fixed_reinforcements_1"
	end
	Util_StartIntel(function()
			CTRL.Subtitle_PlayNarrativeEvent(intel)
			CTRL.WAIT()		
		end)
end


function Skirmish_SetWeaponsDroppable(thing)
	if scartype(thing) == ST_SGROUP then
		SGroup_ForEach(thing,  function(sgroup, index, squad)
				Skirmish_SetWeaponsDroppable(squad)
			end)
	elseif scartype(thing) == ST_SQUAD then
		table.insert(_skirmish.weapon_drop_squads, Squad_GetID(thing))
		if not Rule_Exists(Skirmish_DelayedSetWeaponDroppable) then
			Rule_AddOneShot(Skirmish_DelayedSetWeaponDroppable, 0.5)
		end
	end
end


-- Modifies weapon drop rate of a squad
-- Use a delayed function since Bazooka squads are borked ortherwise
function Skirmish_DelayedSetWeaponDroppable()
	for _, squad_id in pairs(_skirmish.weapon_drop_squads) do
		if Squad_IsValid(squad_id) then
			local squad = Squad_FromID(squad_id)
			if Squad_IsAlive(squad)
				and not (Squad_IsOfType(squad, "building")
					or Squad_IsOfType(squad, "airplane")
					or Squad_IsOfType(squad, "building")
					or Squad_IsCasualty(squad)) then
				for _, weapon in pairs(Squad_GetAttachedWeapons(squad)) do
					Squad_OverrideItemDropChance(squad, weapon, 1.0)
				end
				if Squad_IsOfType(squad, "teamweapon") then
					Squad_SetTeamWeaponDestroyOnAbandonChance(squad, 0.0)
				end
			end
		end
	end
	_skirmish.weapon_drop_squads = {}
end



-- Rule that fires sporadic flares to reveal objective target in the fog of war
function Skirmish_Flare(context, data)
	local pos
	local i = 0
	repeat
		i = i + 1
		local target = primary.targets[World_GetRand(1, #primary.targets)]
		if Item_IsAlive(target) and not Player_CanSeePosition(local_player, Util_GetPosition(target)) then
			pos = Prox_GetRandomPosition(Util_GetPosition(target), 35, 5)
		end
	until pos or i > 5
	if pos then
		Entity_SpawnLiveMunition(BP_GetWeaponBlueprint("4_2_inch_heavy_mortar_flare_uk"), Player_GetID(local_player), pos, pos)
	end
	--Rule_AddOneShot(Skirmish_Flare, World_GetRand(60,75) + Scale(1,25))
end


-----------------------------------------------------------------------
-- Rescue mode
-----------------------------------------------------------------------

-- There are two sets of markers - one for each base.
-- Returns the base number (1 or 2) to which the given player is closest 
function Skirmish_GetBase(player)
	if not _skirmish.base then
		local base_markers = {}
		local num = 1
		while Marker_Exists("mkr_base_"..num, "") do
			table.insert(base_markers, Marker_FromName("mkr_base_"..num, ""))
			num = num + 1
		end
		
		local shortest_distance = 999
		local nearest_base
		for base, base_marker in pairs(base_markers) do
			local distance =  Util_GetDistance(Marker_GetPosition(base_marker), Player_GetStartingPosition(Game_GetLocalPlayer()))
			if distance < shortest_distance then
				shortest_distance = distance
				_skirmish.base = base
			end
		end

		_skirmish.enemy_base = 1
		if _skirmish.base == 1 then 
			_skirmish.enemy_base = 2
		end
	end
	if player == Game_GetLocalPlayer() then
		return _skirmish.base
	end
	return _skirmish.enemy_base
end


function Skirmish_GetMarkers(marker_name, player, sequence)
	local base = Skirmish_GetBase(player or Game_GetLocalPlayer())
	if sequence then
		return Marker_GetSequence(marker_name.."_"..base .."_", "")	
	elseif Marker_Exists(marker_name.."_"..base, "") then
		return Marker_FromName(marker_name.."_"..base, "")
	end
end


-- Returns map entry/exit location
function Skirmish_GetMapEntryPosition(player)
	local pos
	if Player_HasMapEntryPosition(player) then
		return Player_GetMapEntryPosition(player)
	end
	-- Fallback position since Player_GetMapEntryPosition() fails if map entry is not in a valid territory sector
	local mkr = Skirmish_GetMarkers("mkr_exit", player, false)
	if mkr then
		return Marker_GetPosition(mkr)
	end
	return Player_GetStartingPosition(player)
end


function Skirmish_BuffRescuees()	
	local sg_allies = SGroup_FromName("sg_allies")
	local eg = EGroup_CreateUnique()
	SGroup_GetHoldEGroup(sg_allies, eg)
	if not EGroup_IsEmpty(eg) then
		Modify_Armor(eg, 35)
		EGroup_SetInvulnerable(eg, 0.5, 9*60)
	end
	EGroup_Destroy(eg)
end


function Skirmish_InitModeRescue()

	Skirmish_RemoveVictoryPoints()
	Core_UnregisterModule("Tickets")
	Core_UnregisterModule("VictoryPoint")
	Core_UnregisterModule("Territory")
	Core_UnregisterModule("EntityLoss")

	TicketUI_SetVisibility(false, false, false)

	AI_SetPersonality(enemy_player, "default_ai_personality_missions.xml")

	-- Spawn allies
	World_EnableSharedLineOfSight(local_player, allied_player, false)
	local sg_allies = SGroup_CreateIfNotFound("sg_allies")
	local sgs = {}
	local ally_sbps = {
		americans = { SBP.AMERICAN.RIFLEMEN_US, SBP.AMERICAN.SCOUT_US },
		british = { SBP.BRITISH.COMMANDO_UK, SBP.BRITISH.TOMMY_UK }
	}
	for i, mkr_rescue in pairs(Skirmish_GetMarkers("mkr_rescue", local_player, true)) do
		local sg = SGroup_CreateUnique()
		local sbp = ally_sbps[Player_GetRaceName(local_player)][i]
		Util_CreateSquads(allied_player, {sg, sg_allies}, sbp, mkr_rescue)
		Util_GarrisonNearbyBuilding(sg, mkr_rescue, 10)
	end
	SGroup_EnableUIDecorator(sg_allies, true)
	Modify_ReceivedDamage(sg_allies, 0.05, true)
	mod_armor = Modify_Armor(sg_allies, 15)
	mod_vision = Modify_SightRadius(sg_allies, 0.1)
	mod_damage = Modify_WeaponAccuracy(sg_allies, "hardpoint_01", 0.1)
	Rule_AddOneShot(Skirmish_BuffRescuees, 3)

	-- Flare
	local pos = Prox_GetRandomPosition(sg_allies, 12, 10)
	Entity_SpawnLiveMunition(BP_GetWeaponBlueprint("4_2_inch_heavy_mortar_flare_uk"), Player_GetID(local_player), pos, pos)

	-- Spawn enemy defenses
	local mkr_bunkers = Table_GetRand(Skirmish_GetMarkers("mkr_bunker", enemy_player, true), Scale({0,1,2,2,3}))
	for i, mkr_bunker in pairs(mkr_bunkers) do
		local eg = EGroup_CreateUnique()
		local pos = Marker_GetPosition(mkr_bunker)
		local facing = World_GetOffsetPosition(pos, Marker_GetDirection(mkr_bunker), OFFSET_FRONT, 12.0)
		Util_CreateEntities(enemy_player, eg, EBP.GERMAN.BUNKER_GER, pos, 1, facing, true, nil, true)
		Cmd_InstantUpgrade(eg, BP_GetUpgradeBlueprint("mg42_bunker_ger"))
		EGroup_Destroy(eg)
	end

	-- Remove enemy breach abilities to prevent dislodging of allied troops
	Player_SetAbilityAvailability(enemy_player, ABILITY.GERMAN.BREACH_GRENADIER, ITEM_REMOVED)
	Player_SetAbilityAvailability(enemy_player, ABILITY.GERMAN.BREACH_FALLSCHIRMJAGER, ITEM_REMOVED)
	Player_SetAbilityAvailability(enemy_player, ABILITY.GERMAN.BREACH_FLAMETHROWER_GUASTATORI_GER, ITEM_REMOVED)

	-- Enemy behaviour prefab
	local prefab_hold = AI_AddPrefab(enemy_player, "rescue_hold", "Hold", 35, 1, 4, false, true)	
	AI_SetPrefabTarget_Position(prefab_hold, enemy_player, SGroup_GetPosition(sg_allies))

	-- Spawn initial enemies
	sg_enemies = SGroup_CreateUnique()
	for i = 1, Scale(2, 4, math.round) do
		Util_CreateSquads(enemy_player, sg_enemies, SBP.GERMAN.GRENADIER_GER, Prox_GetRandomPosition(SGroup_GetPosition(sg_allies),25,5), nil, 1)
	end

	_skirmish.narrative.rescue.kills_required = Scale(5, 15, math.round)

	primary = {
		Title = _skirmish.narrative.rescue.obj_text,	--"Rescue the isolated troops"
		Type = OT_Primary,
		Intel_Start = function()
			CTRL.Event_Delay(2)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.rescue.intro1)
			CTRL.WAIT()
		end,
		OnStart = function()
			Objective_Start(subobjective_1, false, false)
			Objective_Start(subobjective_2, false, false)
			local eg = EGroup_CreateUnique()
			SGroup_GetHoldEGroup(SGroup_FromName("sg_allies"), eg)
			Objective_AddHealthBar(subobjective_2, 2, SGroup_FromName("sg_allies"), "")
			Objective_AddUIElements(subobjective_2, eg, true, _skirmish.narrative.rescue.hint_text, true, 2, nil, nil, nil, "PrimaryObjectiveDataTemplate")
		end,
		IsComplete = function()
			return Objective_AreSubObjectivesComplete(primary, ANY)
		end,
		IsFailed = function()
			return Objective_AreSubObjectivesFailed(primary, ANY)
		end,
		Intel_Complete = function()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.rescue.victory)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		Intel_Fail = function()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.rescue.defeat)
			CTRL.WAIT()
			Rule_AddOneShot(ShowCampaignBattleAfterActionReport, ui_popup_duration)
		end,
		PreComplete = Skirmish_FailBonusObjective,
		PreFail = Skirmish_FailBonusObjective,
	}
	subobjective_1 = {
		Title = _skirmish.narrative.rescue.subobj1_text1,		--"Break the enemy encirclement"
		Type = OT_Primary,
		Parent = primary,
		IsComplete = function()
			_skirmish.narrative.rescue.kills = _skirmish.narrative.rescue.kills or 0
			if _skirmish.narrative.rescue.kills >= _skirmish.narrative.rescue.kills_required then
				_skirmish.match_result = Skirmish_CreateMatchResult(local_player)
				Core_CallDelegateFunctions("OnWinConditionTriggered", _skirmish.match_result)
			end
			return Skirmish_HasPlayerWon()
		end,
	}
	subobjective_2 = {
		Title = _skirmish.narrative.rescue.subobj2_text,		--"Ally health"
		Type = OT_Primary,
		Parent = primary,
		IsFailed = function()
			if SGroup_CountSpawned(SGroup_FromName("sg_allies")) == 0 then 
				_skirmish.match_result = Skirmish_CreateMatchResult(enemy_player)
				Core_CallDelegateFunctions("OnWinConditionTriggered", _skirmish.match_result)
			end
			return Skirmish_HasPlayerLost()
		end,
	}
	Objective_Register(primary)
	Objective_Register(subobjective_1)
	Objective_Register(subobjective_2)

	Rule_AddInterval(Rescue_CanSeeAllies, 1, nil, mission_rule)
	Rule_AddInterval(Rescue_AllyHealthVO, 1, nil, mission_rule)
	Rule_AddInterval(Rescue_ScheduleSpawns, 1, {
			{ sbp = SBP.GERMAN.ARMORED_CAR_GER, time = Scale(200,160), count = 1, upgrades = {} },
			{ sbp = SBP.GERMAN.JAEGER_GER, time = Scale(360,240), count = 1, upgrades = {BP_GetUpgradeBlueprint("panzerschrek_jaeger_ger")} },
			{ sbp = SBP.GERMAN.PANZERGRENADIER_GER, time = Scale(380,340), count = 2, upgrades = {} },
			{ sbp = SBP.GERMAN.ARMORED_CAR_GER, time = Scale(420,380), count = 1, upgrades = {} },
			{ sbp = SBP.GERMAN.PANZER_IV_GER, time = Scale(580,480), count = 1, upgrades = {} },
		}, mission_rule)
	--Rule_AddOneShot(Rescue_StopAIProduction, 13*60, nil, mission_rule)
end

-- Rescue rule
function Rescue_StopAIProduction(context, data)
	Player_SetPopCapOverride(enemy_player, 0)
end

-- Rescue rule
function Rescue_ScheduleSpawns(context, data)
	local time = World_GetGameTime()
	for i, spawn in pairs(data) do
		if time >= spawn.time then
			local enemy_entry_points = Skirmish_GetMarkers("mkr_entry", enemy_player, true)
			Util_CreateSquads(enemy_player, nil, spawn.sbp, enemy_entry_points[World_GetRand(1,2)], nil, spawn.count, nil, nil, nil, spawn.upgrades)
			table.remove(data, i)
			break
		end
	end
	if #data == 0 then
		Rule_RemoveMe()
	end
end

-- Rescue rule
function Rescue_AllyHealthVO(context)
	if SGroup_Exists("sg_allies") then
		local sg_allies = SGroup_FromName("sg_allies")
		if SGroup_IsEmpty(sg_allies) then
			Rule_RemoveMe()
		elseif SGroup_GetAvgHealth(sg_allies) <= 0.25 and _skirmish.narrative.rescue.vo == _skirmish.narrative.rescue.damage2 then
			if not Rule_Exists(Rescue_PlayVOWarning) then
				_skirmish.narrative.rescue.vo = _skirmish.narrative.rescue.damage3
				Rule_Add(Rescue_PlayVOWarning)
			end
			Rule_RemoveMe()
		elseif SGroup_GetAvgHealth(sg_allies) <= 0.5 and voLine == _skirmish.narrative.rescue.damage1 then
			if not Rule_Exists(Rescue_PlayVOWarning) then
				_skirmish.narrative.rescue.vo = _skirmish.narrative.rescue.damage2
				Rule_Add(Rescue_PlayVOWarning)
			end
		elseif SGroup_GetAvgHealth(sg_allies) <= 0.75 and voLine == "" then
			if not Rule_Exists(Rescue_PlayVOWarning) then
				_skirmish.narrative.rescue.vo = _skirmish.narrative.rescue.damage1
				Rule_Add(Rescue_PlayVOWarning)
			end
		end
	end
end

-- Rescue rule
function Rescue_PlayVOWarning(context)
	if not Event_IsAnyRunning() then	
		Util_StartIntel(function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.rescue.vo)
				CTRL.WAIT()	
			end)
		Rule_RemoveMe()
	end
end


-- Rescue rule
function Rescue_CanSeeAllies(context)
	local sg_allies = SGroup_FromName("sg_allies")
	if Player_CanSeeSGroup(local_player, sg_allies, ANY) and World_GetGameTime() > 45 then
		Modifier_Remove(mod_armor)
		Modifier_Remove(mod_vision)
		World_EnableSharedLineOfSight(local_player, allied_player, true)
		Util_StartIntel(function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.rescue.allies_spotted)
				CTRL.WAIT()
			end)
		_skirmish.narrative.rescue.kills = 0
		Objective_UpdateText(subobjective_1, _skirmish.narrative.rescue.subobj1_text2, nil, true, true)	-- "Eliminate nearby squads"
		Objective_SetCounter(subobjective_1, _skirmish.narrative.rescue.kills, _skirmish.narrative.rescue.kills_required)
		Rule_AddGlobalEvent(Rescue_CountKills, GE_SquadKilled)
		Rule_RemoveMe()
	end
end


function Rescue_CountKills(context)
	if Squad_GetPlayerOwner(context.victim) == enemy_player and not Squad_IsOfType(context.victim, "airplane") then  		
		_skirmish.narrative.rescue.kills = _skirmish.narrative.rescue.kills + 1
		Objective_SetCounter(subobjective_1, _skirmish.narrative.rescue.kills, _skirmish.narrative.rescue.kills_required)
		if  _skirmish.narrative.rescue.kills >= _skirmish.narrative.rescue.kills_required then
			Rule_RemoveMe()
		end
	end
end


-----------------------------------------------------------------------
-- Bonus objectives
-----------------------------------------------------------------------

function Skirmish_InitBonusObjective()
	local bonus
	local bonus_objectives = {
		"mines",
		"minelaying",
		"supplies",
		"vip",
		"sniper",
		"panzer",
		"convoy",
		"schreck",
		"battery",
		"veteran",
		--"inspection",
		"atgun",
		"fieldtest",
		"recovery",
	}
	--local options = _skirmish.options.section_bonus.option_bonus.enum_items
	--local option = _skirmish.options.section_bonus.option_bonus.enum_value		
	--if option == options.bonus_none then
		--return		
	--end

	-- Use command line option if provided
	if Misc_IsCommandLineOptionSet("bonus") then 
		bonus = tonumber(Misc_GetCommandLineString("bonus"))
		if bonus ~= nil then
			if bonus >= 1 and bonus <= #bonus_objectives then 
				bonus = bonus_objectives[bonus]
			else
				bonus = nil
			end
		elseif Table_Contains(bonus_objectives, Misc_GetCommandLineString("bonus")) then 
			bonus = Misc_GetCommandLineString("bonus")
		elseif bonus == "none" then
			return
		else
			bonus = nil
		end
	end
	
	-- Override bonus delay if command line option provided
	local bonus_delay
	if Misc_IsCommandLineOptionSet("-bonus_delay") then
		bonus_delay = tonumber(Misc_GetCommandLineString("bonus_delay"))
		if bonus_delay then
			bonus_delay = math.max(10, math.abs(bonus_delay))
		end
	end

	-- Use mission_data.bonus if provided
	local campaign = Game_RetrieveTableData(campaign_data_key, false)
	if not bonus and campaign and campaign.mission_data and campaign.mission_data.bonus then
		bonus = campaign.mission_data.bonus
	end

	-- Pick at random otherwise
	if not bonus or not Table_Contains(bonus_objectives, bonus) then		
		--local eg = Player_GetEntitiesFromType(enemy_player, "mine")
		--local is_area_mined = EGroup_Count(eg) > 16
		--EGroup_Destroy(eg)

		--local bonus_index = World_GetRand(2, #bonus_objectives)
		--if is_area_mined then
			--bonus_index = 1		-- Favour mine-clearing
		--end
		
		local bonus_index = World_GetRand(2, #bonus_objectives)
		if _skirmish.player_attacking then 
			bonus_index = World_GetRand(1, #bonus_objectives)
		end

		-- If campaign exists, ensure bonus objective not used in last 5 missions (and don't use sniper bonus during rescue mission)
		if campaign then
			local skirmish_events = Util_StringSplit(campaign.skirmish_events or "")
			while Table_Contains(skirmish_events, tostring(bonus_index))
				or (_skirmish.mode == "rescue" and bonus_objectives[bonus_index]) == "sniper" do
				bonus_index = World_GetRand(2,  #bonus_objectives)
			end
			if bonus_index > 0 then
				local s = ""
				for i = 1, math.min(4, #skirmish_events) do
					s = s .. skirmish_events[i] .. ","
				end
				deferred_campaign_data.skirmish_events = tostring(bonus_index) .. "," .. s
			end
		end
		bonus = bonus_objectives[bonus_index]
	end
	
	print("Skirmish_InitBonusObjective() - "..bonus)
	
	if bonus == "mines" then
		Rule_AddOneShot(Skirmish_StartMines, 10, nil, bonus_rule)
	elseif bonus == "minelaying" then
		Rule_AddOneShot(Skirmish_StartMineLaying, bonus_delay or World_GetRand(90, 120), nil, bonus_rule)
	elseif bonus == "supplies" then
		Rule_AddOneShot(Skirmish_StartSupplies, bonus_delay or World_GetRand(90, 120), nil, bonus_rule)
	elseif bonus == "vip" then		
		Rule_AddOneShot(Skirmish_StartVIP, bonus_delay or World_GetRand(90, 120), nil, bonus_rule)
	elseif bonus == "sniper" then
		Rule_AddOneShot(Skirmish_StartSniper, bonus_delay or World_GetRand(90, 120), nil, bonus_rule)
	elseif bonus == "panzer" then
		Rule_AddOneShot(Skirmish_StartPanther, bonus_delay or Scale(320, 240), nil, bonus_rule)
	elseif bonus == "convoy" then  
		Rule_AddOneShot(Skirmish_StartConvoy, bonus_delay or Scale(320, 240), nil, bonus_rule)
	elseif bonus == "schreck" then 
		Rule_AddOneShot(Skirmish_StartPanzerschreck, bonus_delay or World_GetRand(90, 120), nil, bonus_rule)
	elseif bonus == "battery" then
		Rule_AddOneShot(Skirmish_StartBattery, bonus_delay or World_GetRand(90, 120), nil, bonus_rule)
	elseif bonus == "veteran" then
		Rule_AddOneShot(Skirmish_StartVeteran, 10, nil, bonus_rule)
	--elseif bonus == "inspection" then
		--Rule_AddOneShot(Skirmish_StartInspection, 10, nil, bonus_rule)
	elseif bonus == "atgun" then
		Rule_AddOneShot(Skirmish_StartAT, bonus_delay or World_GetRand(90, 120), nil, bonus_rule)
	elseif bonus == "fieldtest" then
		Rule_AddOneShot(Skirmish_StartFieldTest, bonus_delay or World_GetRand(90, 120), nil, bonus_rule)
	elseif bonus == "recovery" then
		Rule_AddOneShot(Skirmish_StartRecovery, bonus_delay or World_GetRand(60, 90), nil, bonus_rule)
	end
	
	_skirmish.bonus = bonus
end


-- Entity event callback for GE_DamageReceived
-- Triggers a counterstrike when enemy HQ is damaged
function Skirmish_EnemyHQDamaged(context, data)
	if context.damage > 0 
		and context.attacker 
		and not World_OwnsEntity(context.victim) 
		and Entity_GetPlayerOwner(context.victim) == enemy_player
		and Entity_GetHealthPercentage(context.victim) < 0.95
		and scartype(context.attacker) == ST_ENTITY
		and not World_OwnsEntity(context.attacker)
		and Entity_IsPartOfSquad(context.attacker)
		and not Squad_IsOfType(Entity_GetSquad(context.attacker), "airplane") then
		Skirmish_Counterstrike({context.victim}, nil, World_GetRand(2,6), Skirmish_TriggerReserves)
	end
end


-- Causes AI enemy player to perform a company-appropriate counterstrike 
-- against player squads in the vicinity of the given targets. 
function Skirmish_Counterstrike(targets, chance, delay, event)

	if Misc_IsCommandLineOptionSet("counterstrike") and tonumber(Misc_GetCommandLineString("counterstrike")) ~= nil then
		chance = math.min(1.0, math.max(0.1, tonumber(Misc_GetCommandLineString("counterstrike"))))
	end
	chance = chance or Scale(0.30, 0.75)

	-- Enforce max number of counterstrike events and minimum interval between them
	_skirmish.event_time = _skirmish.event_time or 0
	_skirmish.event_count = _skirmish.event_count or 0
	if not _skirmish.match_result 
		and not Rule_Exists(Skirmish_StartCounterstrike)
		and not Rule_Exists(Skirmish_ReserveBehavior)
		and (World_GetGameTime() - _skirmish.event_time) > Scale(180, 90)
		and _skirmish.event_count <= Scale({0,1,1,2,2}) then
		_skirmish.event_count = _skirmish.event_count + 1
		_skirmish.event_time = World_GetGameTime()
		if World_GetRand(1,100) < (chance*100) then
			Rule_AddOneShot(Skirmish_StartCounterstrike, delay or World_GetRand(1,7), {targets = targets, event = event}, mission_rule)
		end
	end
end


-- Rule that triggers an event geared toward retaking victory points.
-- data = list of potential target entities
function Skirmish_StartCounterstrike(context, data)
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_StartCounterstrike, 3, data, mission_rule)
	else
		local company_events = {
			company_armored_ger = {Skirmish_TriggerReserves, Skirmish_TriggerBarrage},
			company_infantry_ger = {Skirmish_TriggerReserves, Skirmish_TriggerBarrage},
			company_luftwaffe_ger = {Skirmish_TriggerFallschirmjager, Skirmish_TriggerStuka},
			company_mechanized_ger = {Skirmish_TriggerReserves, Skirmish_TriggerBarrage},
			default = {Skirmish_TriggerReserves, Skirmish_TriggerBarrage, Skirmish_TriggerFallschirmjager, Skirmish_TriggerStuka},
		}
		local events = company_events[_skirmish.company.enemy]
		if not events then
			events = company_events.default
		end
		-- Prevent repeats
		_skirmish.events = _skirmish.events or {}
		for i = 1, 5 do 
			event = events[World_GetRand(1, #events)]
			if not Table_Contains(_skirmish.events, event) then
				break
			end
		end
		-- Use specific event if provided
		if data.event then
			event = data.event
		end
		table.insert(_skirmish.events, event)
		
		event(nil, data.targets)
	end
end


function Skirmish_Unlock(player, upgrades, ability)
	if scartype(upgrades) == ST_TABLE then
		for _, upgrade in pairs(upgrades) do
			Skirmish_Unlock(player, upgrade)
		end
	elseif scartype(upgrades) == ST_STRING then
		Cmd_InstantUpgrade(player, BP_GetUpgradeBlueprint(upgrades))
	elseif scartype(upgrades) ~= ST_NIL then
		Cmd_InstantUpgrade(player, upgrades)
	end

	if ability then
		Skirmish_AddPlayerAbilityIfNotExists(player, ability)
	end
end


function Skirmish_AddPlayerAbilityIfNotExists(player, ability)
	local ability_bp = ability
	if scartype(ability) == ST_STRING then
		ability_bp = BP_GetAbilityBlueprint(ability)
	end
	if ability_bp and not Player_HasAbility(player, ability_bp) then
		Player_AddAbility(player, ability_bp)
	end
end


--Returns table containing positions of high value targets (typically victory and/or territory points)
function Skirmish_GetTargets(max_targets, only_defended, only_vps)
	local targets = {}
	local max = max_targets or 3
	local sg = SGroup_CreateUnique()
	local _IsDefended = function(pos)
		Player_GetAllSquadsNearMarker(Game_GetLocalPlayer(), sg, pos, 30)
		SGroup_Filter(sg,  {"building", "base_defense", "auto_builder", "airplane"}, FILTER_REMOVE)
		return SGroup_CountSpawned(sg) > 0
	end
	local _FilterTargets = function(eg)
		EGroup_ForEach(eg, function(egroup, i, entity)
			if Entity_IsActive(entity) and not World_OwnsEntity(entity) and Entity_GetPlayerOwner(entity) == Game_GetLocalPlayer() then
				if not only_defended or _IsDefended(Entity_GetPosition(entity)) then 
					table.insert(targets, entity)
				end
			end
		end)
	end
	
	-- Prioritize VPs 
	_FilterTargets(_skirmish.victory_points)
	
	if #targets == 0 then
		-- otherwise target front line territory points with defending squads
		local furthest_distance = 0
		local eg = EGroup_CreateUnique()
		World_GetStrategyPoints(eg, false)
		_FilterTargets(eg)
		EGroup_Destroy(eg)
		table.sort(targets, function(a, b)
				local start = Player_GetStartingPosition(Game_GetLocalPlayer())
				return Util_GetDistanceSquared(a, start) > Util_GetDistanceSquared(b, start)
			end)
	end
	while #targets > max do
		table.remove(targets, #targets)
	end	
	SGroup_Destroy(sg)
	return targets
end


-- Rule to adds a bonus objective map blip. 
function Skirmish_CreateMapBlip(objective, thing)
	if not objective.blips then 
		objective.blips = {}
	end
	table.insert(objective.blips, UI_CreateMinimapBlip(thing, -1, "BonusObjectiveDataTemplate"))
end

-- Removes a bonus objective map blips. 
function Skirmish_RemoveMapBlips(objective)
	if objective.blips then 
		for i = #objective.blips, 1, -1 do
			UI_DeleteMinimapBlip(objective.blips[i])
			table.remove(objective.blips, i)
		end
	end
end


-----------------------------------------------------------------------
-- Bonus objective debug functions
-----------------------------------------------------------------------

-- Called by core.scar to set up the initial state
function Skirmish_Preset()
	-- Add debug menu items
	CheatMenu_RegisterCheatFunction(Skirmish_TriggerBarrage, "Enemy bombardment", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugStuka, "Enemy dive bomb", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugFallschirmjager, "Enemy paradrop", false)	
	--CheatMenu_RegisterCheatFunction(Skirmish_DebugGoliath, "Enemy Goliaths", false)	
	
	CheatMenu_RegisterCheatFunction(Skirmish_DebugMines, "Bonus: Mine-clearing", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugMineLaying, "Bonus: Mine-laying", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugSupplies, "Bonus: Supplies", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugVIP, "Bonus: VIP", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugPanther, "Bonus: Panther", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugConvoy, "Bonus: Convoy", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugSniper, "Bonus: Sniper", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugPanzerschreck, "Bonus: Panzerschreck", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugBattery, "Bonus: Howitzer", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugVeteran, "Bonus: Veteran", false)
	--CheatMenu_RegisterCheatFunction(Skirmish_DebugInspection, "Bonus: Inspection", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugAT, "Bonus: AT", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugFieldTest, "Bonus: Field Test", false)
	CheatMenu_RegisterCheatFunction(Skirmish_DebugRecovery, "Bonus: Recovery", false)
end

function Skirmish_Debug(debug_function)
	if not Event_IsAnyRunning() then 
		if bonus and not Objective_IsComplete(bonus) then 
			Objective_Fail(bonus, false, false)
		end
		bonus = nil
		debug_function()
	end	
end

function Skirmish_DebugMines()
	EGroup_DeSpawn(Player_GetEntitiesFromType(enemy_player, "mine"))
	Skirmish_Debug(Skirmish_StartMines)
end

function Skirmish_DebugMineLaying()
	Skirmish_Debug(Skirmish_StartMineLaying)
end

function Skirmish_DebugStuka()
	Skirmish_TriggerStuka()
end

function Skirmish_DebugFallschirmjager()
	Skirmish_TriggerFallschirmjager()
end

function Skirmish_DebugGoliath()
	Skirmish_TriggerGoliath()
end

function Skirmish_DebugSupplies()
	Skirmish_Debug(Skirmish_StartSupplies)
end

function Skirmish_DebugVIP()
	Skirmish_Debug(Skirmish_StartVIP)
end

function Skirmish_DebugPanther()
	Skirmish_Debug(Skirmish_StartPanther)
end

function Skirmish_DebugConvoy()
	Skirmish_Debug(Skirmish_StartConvoy)
end

function Skirmish_DebugSniper()
	Skirmish_Debug(Skirmish_StartSniper)
end

function Skirmish_DebugPanzerschreck()
	Skirmish_Debug(Skirmish_StartPanzerschreck)
end

function Skirmish_DebugBattery()
	Skirmish_Debug(Skirmish_StartBattery)
end

function Skirmish_DebugVeteran()
	Skirmish_Debug(Skirmish_StartVeteran)
end

--function Skirmish_DebugInspection()
	--Skirmish_Debug(Skirmish_StartInspection)
--end

function Skirmish_DebugAT()
	Skirmish_Debug(Skirmish_StartAT)
end

function Skirmish_DebugFieldTest()
	Skirmish_Debug(Skirmish_StartFieldTest)
end

function Skirmish_DebugRecovery()
	Skirmish_Debug(Skirmish_StartRecovery)
end


-----------------------------------------------------------------------
-- Off-map artillery barrage
-----------------------------------------------------------------------


-- Off-map artillery barrage on VPs
function Skirmish_TriggerBarrage(context, data)
	if Event_IsAnyRunning() then 
		Rule_AddOneShot(Skirmish_TriggerBarrage, 5, data, mission_rule)
	else
		local targets = data or Skirmish_GetTargets(Scale(0,3, math.ceil), true)
		if #targets > 0 then
			Util_StartIntel(function()
					--CTRL.Actor_PlaySpeech(ACTOR.GENERAL, "The Germans are bombarding our front line! Take cover!")
					CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_barrage.alert)
					CTRL.WAIT()
				end)
			Rule_AddOneShot(Skirmish_DoBarrage, Scale(10,4,math.floor), 
				{player = enemy_player, targets = targets, shots_remaining = #targets * World_GetRand(6, 9)},
				mission_rule)
			for _, target in pairs(targets) do
				UI_CreateMinimapBlip(Util_GetPosition(target), 10.0, "attack_here")
				EventCue_Create(11214711, "high_priority", target, "icons/races/common/abilities/artillery_barrage", "", "")	-- "Artillery incoming!"
			end
		end
	end
end

-- Rule used to trigger single artillery strike on target(s)
function Skirmish_DoBarrage(context, data)
	local ability = ABILITY.GERMAN.M_SINGLE_SHOT_ARTILLERY_GER
	Skirmish_AddPlayerAbilityIfNotExists(enemy_player, ability)
	local pos = Prox_GetRandomPosition(data.targets[World_GetRand(1, #data.targets)], 16+Scale(12, 0, math.floor), 4 + Scale(6, 0, math.floor))
	Cmd_Ability(enemy_player, ability, pos, nil, true, true)
	Player_ResetAbilityCooldowns(enemy_player, ability)
	data.shots_remaining = data.shots_remaining - 1
	if data.shots_remaining > 0 then 
		Rule_AddOneShot(Skirmish_DoBarrage, World_GetRand(1,4) / 2.0, data, mission_rule)
	end
end

-----------------------------------------------------------------------
-- Stuka Dive Bomb
-----------------------------------------------------------------------

-- Dive bomb VPs
function Skirmish_TriggerStuka(context, data)
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_TriggerStuka, 5, data, mission_rule)
	else
		local targets = data or Skirmish_GetTargets(Scale(1,1,1,2,2,3), true)
		if #targets > 0 then
			Util_StartIntel(function()
					CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_stuka.alert)
					CTRL.WAIT()
				end)
			Rule_AddOneShot(Skirmish_DoStuka, 8, {targets = targets}, mission_rule)
		end
	end
end

-- Rule used to trigger single stuka attack
function Skirmish_DoStuka(context, data)
	local ability = BP_GetAbilityBlueprint("m_dive_bomb_ger")
	Skirmish_AddPlayerAbilityIfNotExists(enemy_player, ability)
	local pos = Prox_GetRandomPosition(data.targets[#data.targets], 17, 6)
	local dir = Util_GetDirectionFromAtoB(Player_GetStartingPosition(enemy_player), pos)
	Cmd_Ability(enemy_player, ability, pos, dir, true, true)
	Player_ResetAbilityCooldowns(enemy_player, ability)
	table.remove(data.targets, #data.targets)
	if #data.targets > 0 then 
		Rule_AddOneShot(Skirmish_DoStuka, World_GetRand(2,6), data, mission_rule)
	end
end


-----------------------------------------------------------------------
-- Fallschirmjager paradrop (preceded by smokescreen)
-----------------------------------------------------------------------

-- Airborne assault 
function Skirmish_TriggerFallschirmjager(context, data)
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_TriggerFallschirmjager, 5, data, mission_rule)
	else
		local targets = data or Skirmish_GetTargets()
		if #targets > 0 then
			Util_StartIntel(function()
					CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_fallschirm.alert)
					CTRL.WAIT()
				end)
			local smoke_targets = {}
			local fallshirm_targets = {}
			for i = 1, #targets do
				table.insert(smoke_targets, Prox_GetRandomPosition(targets[i], 12, 5))
			end
			for i = 1, Scale(1,2,3,3) do
				table.insert(fallshirm_targets, Prox_GetRandomPosition(targets[World_GetRand(1,#targets)], 25, 18))
			end
			local delay = 1
			Rule_AddOneShot(Skirmish_DeploySmokeBomb, delay, { player = enemy_player, targets = smoke_targets }, mission_rule)
			Rule_AddOneShot(Skirmish_DeployFallschirmjager, delay + 5, { player = enemy_player, targets = fallshirm_targets }, mission_rule)
			Rule_AddOneShot(Skirmish_BonusKillFallshirmjager, delay + 40, nil, bonus_rule)
		end
	end
end

-- Rule used to trigger airborne smokescreen on given targets
function Skirmish_DeploySmokeBomb(context, data)
	local ability = BP_GetAbilityBlueprint("m_smoke_bombing_run_ger")
	Skirmish_AddPlayerAbilityIfNotExists(enemy_player, ability)
	local i = #data.targets
	local pos = data.targets[i]
	local dir = Util_GetDirectionFromAtoB(Player_GetStartingPosition(enemy_player), pos)
	Cmd_Ability(enemy_player, ability, pos, dir, true, true)
	Player_ResetAbilityCooldowns(enemy_player, ability)
	table.remove(data.targets, i)
	if #data.targets > 0 then 
		Rule_AddOneShot(Skirmish_DeploySmokeBomb, World_GetRand(2,3), data, mission_rule)
	end
end


-- Rule used to trigger a fallshirmjager airborne assault
function Skirmish_DeployFallschirmjager(context, data)
	print("Skirmish_DeployFallschirmjager()")
	local ability = ABILITY.GERMAN.LUFTWAFFE_RIGHT_2_FALLSCHIRMJAGERS_GER 
	Skirmish_Unlock(enemy_player, "luftwaffe_right_2_fallschirmjagers", ability)
	local i = #data.targets
	local pos = data.targets[i]
	local dir = Util_GetDirectionFromAtoB(Player_GetStartingPosition(enemy_player), pos)
	Cmd_Ability(enemy_player, ability, pos, dir, true, true)
	Player_ResetAbilityCooldowns(enemy_player, ability)
	table.remove(data.targets, i)
	if #data.targets > 0 then 
		Rule_AddOneShot(Skirmish_DeployFallschirmjager, World_GetRand(3,5), data, mission_rule)
	end
end

-- Rule that adds 'kill fallschirmjager' bonus objective
function Skirmish_BonusKillFallshirmjager(context, data)
	if not bonus and not _skirmish.match_result then
		if Event_IsAnyRunning() then
			Rule_AddOneShot(Skirmish_BonusKillFallshirmjager, 5, nil, bonus_rule)
			return
		end
		local sg = Player_GetSquads(enemy_player)
		SGroup_Filter(sg, SBP.GERMAN.FALLSCHIRMJAGERS_GER, FILTER_KEEP)
		if SGroup_CountSpawned(sg) > 0 then
			bonus = {
				Title = _skirmish.narrative.event_fallschirm.obj_text,--"Eliminate Fallschirmjäger squads"
				Type = OT_Bonus,
				threshold = SGroup_CountSpawned(sg),
				sg = sg,
				Intel_start = function()
					CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_fallschirm.start)
					CTRL.WAIT()
				end,
				IsComplete = function()
					local remaining = SGroup_CountSpawned(bonus.sg)
					Obj_SetCounterCount(bonus.ID, bonus.threshold - remaining)
					return remaining == 0
				end,
				OnComplete = function()
					SGroup_Destroy(bonus.sg)
				end,
			}
			Objective_Register(bonus)
			Objective_SetCounter(bonus, 0, SGroup_CountSpawned(sg))
			Objective_Start(bonus, true, true)
		end
	end
end


-----------------------------------------------------------------------
-- Golilath attack
-----------------------------------------------------------------------

function Skirmish_TriggerGoliath(context, data)
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_TriggerGoliath, 3, data, mission_rule)
	else
		local points = data or Skirmish_GetTargets(3, true)
		if #points >  0 then
			local sg = SGroup_CreateUnique()
			-- Get squad(s) near target(s)
			local targets = {}
			for i = 1, World_GetRand(1,Scale({1,1,2,2,3,3,4})) do
				local point = points[((i-1) % #points) + 1]
				Player_GetAllSquadsNearMarker(Game_GetLocalPlayer(), sg, Util_GetPosition(point), 30)
				if SGroup_CountSpawned(sg) > 0 then
					table.insert(targets, {target_id = Squad_GetID(SGroup_GetSpawnedSquadAt(sg, World_GetRand(1, SGroup_CountSpawned(sg))))})
				end
			end
			-- Spawn goliath(s)
			local entry_points = Skirmish_GetMarkers("mkr_entry", enemy_player, true)
			for _, target in pairs(targets) do 
				local goliath = Squad_CreateAndSpawnToward(SBP.GERMAN.GOLIATH_GER, enemy_player, 1, Util_GetPosition(entry_points[World_GetRand(1,2)]), Util_ScarPos(0,0))
				AI_LockSquad(enemy_player, goliath)
				target.goliath_id = Squad_GetID(goliath)
			end
			if #targets > 0 then
				Util_StartIntel(function()
						CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_goliath.alert)
						CTRL.WAIT()
					end)
				Rule_AddInterval(Skirmish_GoliathBehavior, 3, targets, mission_rule)
			end
		end
	end
end


function Skirmish_GoliathBehavior(context, data)
	if scartype(data) == ST_TABLE and #data > 0 then
		local goliaths_remaining = 0
		local sg = SGroup_CreateUnique()
		for _, entry in pairs(data) do 
			if Squad_IsValid(entry.goliath_id) then
				local goliath = Squad_FromID(entry.goliath_id)
				SGroup_Clear(sg)
				SGroup_Add(sg, goliath)
				goliaths_remaining = goliaths_remaining + 1
				if Squad_IsValid(entry.target_id) then
					local target = Squad_FromID(entry.target_id)
					if Util_GetDistance(goliath, target) > 8 then
						Cmd_Move(sg, Util_GetPosition(target))
					else
						Cmd_Ability(sg, ABILITY.GERMAN.SELF_DESTRUCT_GOLIATH_GER, sg)
					end
				else
					-- Find new target
					local sg_targets = SGroup_CreateUnique()
					Player_GetAllSquadsNearMarker(Game_GetLocalPlayer(), sg_targets, Util_GetPosition(goliath), 60)
					if SGroup_CountSpawned(sg_targets) > 0 then
						local nearest_target = SGroup_GetSpawnedSquadAt(sg_targets, 1)
						for i = 2, SGroup_CountSpawned(sg_targets) do
							if Util_GetDistance(goliath, SGroup_GetSpawnedSquadAt(sg_targets, i)) < Util_GetDistance(goliath, nearest_target) then
								nearest_target = SGroup_GetSpawnedSquadAt(sg_targets, i)
							end
						end
						entry.target_id = Squad_GetID(nearest_target)
					end
					SGroup_Destroy(sg_targets)
				end
			end
		end
		SGroup_Destroy(sg)
		if goliaths_remaining == 0 then
			Rule_RemoveMe()
		end
	else
		Rule_RemoveMe()
	end
end

-----------------------------------------------------------------------
-- Off-map reinforcements
-----------------------------------------------------------------------

function Skirmish_TriggerReserves(context, data)
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_TriggerReserves, 3, data, mission_rule)
	else
		print("Skirmish_TriggerReserves()")
		local points = data or Skirmish_GetTargets(1, true)
		if #points >  0 then
			-- Get squad(s) near target
			local sg_targets = SGroup_CreateUnique()
			Player_GetAllSquadsNearMarker(Game_GetLocalPlayer(), sg_targets, Util_GetPosition(points[1]), 35)
			SGroup_Filter(sg_targets, {"building", "base_defense", "auto_builder", "airplane"}, FILTER_REMOVE)
			if SGroup_CountSpawned(sg_targets) > 0 and not Rule_Exists(Skirmish_ReserveBehavior) then
				local company_reserves = {
					company_infantry_ger = {
						{SBP.GERMAN.STUG_III_GER, BP_GetUpgradeBlueprint("mg42_stug_ger")},
						{SBP.GERMAN.HALFTRACK_STUMMEL_GER, },
						{SBP.GERMAN.GRENADIER_GER},
						{SBP.GERMAN.PIONEER_GER, BP_GetUpgradeBlueprint("flamethrower_pioneer_ger")},
					},
					company_luftwaffe_ger = {
						{SBP.GERMAN.PANZER_IV_GER, BP_GetUpgradeBlueprint("mg42_panzer_ger")},
						{SBP.GERMAN.WIRBELWIND_GER, },
						{SBP.GERMAN.FALLSCHIRMPIONEERS_GER, BP_GetUpgradeBlueprint("grb_39_grenade_launcher_fallschirmpioneer_ger") },
						{SBP.GERMAN.FALLSCHIRMJAGERS_GER, },
					},
					company_mechanized_ger = {
						{SBP.GERMAN.STUG_III_GER, BP_GetUpgradeBlueprint("mg42_stug_ger")},
						{SBP.GERMAN.PANZER_IV_GER, BP_GetUpgradeBlueprint("mg42_panzer_ger")},
						{SBP.GERMAN.PANZERGRENADIER_GER},
						{SBP.GERMAN.PIONEER_GER, BP_GetUpgradeBlueprint("flamethrower_pioneer_ger")},
					},
					company_armored_ger = {
						{SBP.GERMAN.PANZER_IV_CMD_GER, BP_GetUpgradeBlueprint("mg42_panzer_ger")},
						{SBP.GERMAN.PANZER_IV_GER, BP_GetUpgradeBlueprint("mg42_panzer_ger")},
						{SBP.GERMAN.PIONEER_GER, BP_GetUpgradeBlueprint("flamethrower_pioneer_ger")},
						{SBP.GERMAN.PANZERGRENADIER_GER},
					},
				}
				local reserves = company_reserves[_skirmish.company.enemy]
				if not reserves then
					reserves = company_reserves.company_infantry_ger
				end
				local entry_points = Skirmish_GetMarkers("mkr_entry", enemy_player, true)
				Rule_AddInterval(Skirmish_ReserveBehavior, 5, {
					mkr_spawn = Marker_GetPosition(entry_points[1]),
					sg_reserves = SGroup_CreateUnique(),
					sg_targets = sg_targets,
					reserves = reserves 
				}, mission_rule)
				Util_StartIntel(
					function()
						CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_reserves.alert)
						CTRL.WAIT()
					end)
			end
		end
	end
end


function Skirmish_ReserveBehavior(context, data)
	if #data.reserves > 0 then
		local spawn_data = data.reserves[#data.reserves]
		Util_CreateSquads(enemy_player, data.sg_reserves, spawn_data[1], data.mkr_spawn, nil, nil, nil, false, nil, spawn_data[2], Util_ScarPos(0,0))
		UI_CreateMinimapBlip(data.mkr_spawn, 10.0, "attack_here")
		SGroup_ForEach(data.sg_reserves, function(sgroup, index, squad)
				AI_LockSquad(Squad_GetPlayerOwner(squad), squad)
			end)
		table.remove(data.reserves, #data.reserves)
	end
	if SGroup_CountSpawned(data.sg_reserves) > 0 and SGroup_CountSpawned(data.sg_targets) > 0 then
		Cmd_Attack(data.sg_reserves, data.sg_targets, true, false, nil, false)
	else
		SGroup_ForEach(data.sg_reserves, function(sgroup, index, squad)
			AI_UnlockSquad(Squad_GetPlayerOwner(squad), squad)
		end)
		SGroup_Destroy(data.sg_reserves)
		SGroup_Destroy(data.sg_targets)
		Rule_RemoveMe()
	end
end


-----------------------------------------------------------------------
-- Mine clearing bonus objective
-----------------------------------------------------------------------


function Skirmish_StartMines()
	if not Rule_Exists(Skirmish_BonusMines) then
		Skirmish_InitMinefields()
		Rule_AddGlobalEvent(Skirmish_BonusMines, GE_EntityKilled)
	end
end


-- Global event callback for GE_EntityKilled
-- Mine-clearing bonus objective
function Skirmish_BonusMines(context)
	if context.victimOwner ~= nil and context.victimOwner ~= Game_GetLocalPlayer() and Entity_IsOfType(context.victim, "mine") then
		_skirmish.mines_cleared = (_skirmish.mines_cleared or 0) + 1
		if _skirmish.mines_cleared == 1 then
			if not Event_IsAnyRunning() then
				Util_StartIntel(function()
						CTRL.Event_Delay(2)
						CTRL.WAIT()
						--CTRL.Actor_PlaySpeech(ACTOR.GENERAL, "Careful, it appears Jerry mined this area.")
						CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_mines.alert)
						CTRL.WAIT()
					end)
			end
		elseif not bonus then
			local eg = Player_GetEntitiesFromType(enemy_player, "mine")
			local mines_remaining = EGroup_CountSpawned(eg)
			EGroup_Destroy(eg)
			if mines_remaining > 13 then 
				bonus = {
					Title = _skirmish.narrative.event_mines.obj_text,-- "Clear enemy mines" 
					Type = OT_Bonus,
					mines_to_clear = Scale(5, 10, math.round),
					Intel_Start = function()
						CTRL.Event_Delay(3)
						CTRL.WAIT()
						CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_mines.start)
						CTRL.WAIT()
					end,
					IsComplete = function()
						return bonus.mines_to_clear <= 0
					end,
					OnComplete = function()
						Rule_RemoveGlobalEvent(Skirmish_BonusMines)
						EGroup_ForEach(Player_GetEntities(enemy_player), function(egroup, index, entity)
								if Entity_IsOfType(entity, "mine") then
									Entity_DeSpawn(entity)
								end
							end)
						local eg = EGroup_CreateUnique()
						World_GetAllNeutralEntities(eg)
						EGroup_Filter(eg, {BP_GetEntityBlueprint("mine_field_sign_01"), BP_GetEntityBlueprint("mine_field_sign_02")}, FILTER_KEEP)
						EGroup_ForEach(eg, function(egroup, index, entity)
								if not Player_CanSeeEntity(local_player, entity) then
									Entity_DeSpawn(entity)
								end
							end)
						EGroup_Destroy(eg)
					end,
				}
				Objective_Register(bonus)
				Objective_SetCounter(bonus, 0, bonus.mines_to_clear)
				Objective_Start(bonus, true, true)
			end
		elseif bonus and bonus.mines_to_clear and not Objective_IsComplete(bonus) then
			bonus.mines_to_clear = bonus.mines_to_clear - 1
			Objective_IncreaseCounter(bonus, 1)
		end
	end
end

-----------------------------------------------------------------------
-- Mine-laying bonus objective
-----------------------------------------------------------------------

function Skirmish_StartMineLaying()
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_StartMineLaying, 20, nil, bonus_rule)
	elseif not bonus then
		bonus = {
			count = 0,
			threshold = Scale({2,3,4,5,6,7}),
			Title = _skirmish.narrative.event_minelaying.obj_text,-- "Use mines"
			Type = OT_Bonus,
			Intel_Start = function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_minelaying.start)
				CTRL.WAIT()
			end,
			IsComplete = function()
				return bonus.count >= bonus.threshold
			end,
			OnComplete = function()
				Rule_RemoveGlobalEvent(Skirmish_BonusMineLaying)
			end,
		}				
		Objective_Register(bonus)
		Objective_SetCounter(bonus, bonus.count, bonus.threshold)
		Objective_Start(bonus, true, true)
		Rule_AddGlobalEvent(Skirmish_BonusMineLaying, GE_EntityKilled)
		
		-- Make mines cheaper 
		local ebps = {EBP.AMERICAN.MINE_ENGINEER_US, EBP.AMERICAN.MINE_RIFLEMAN_US, EBP.AMERICAN.MINE_GREYHOUND_US, EBP.AMERICAN.OBSTACLE_MINE_FIELD_US, EBP.AMERICAN.MINE_HEAVY_ENGINEER_US, 
			EBP.BRITISH.MINE_SAPPER_UK, EBP.BRITISH.MINE_TOMMY_UK, EBP.BRITISH.MINE_FIELD_SAPPER_UK, EBP.BRITISH.MINE_HEAVY_SAPPER_UK }
		for _, ebp in pairs(ebps) do
			local modifier = Modifier_Create(MAT_EntityType, "entity_cost_munition", MUT_Multiplication, false, 2/3, ebp)
			Modifier_ApplyToPlayer(modifier, local_player, 0)
		end
	end
end


-- Global event callback for GE_EntityKilled
-- Mine-laying bonus objective
function Skirmish_BonusMineLaying(context)
	if context.victimOwner and context.victimOwner == enemy_player and context.killer and scartype(context.killer) == ST_ENTITY then
		if bonus and bonus.count and Entity_IsOfType(context.killer, "mine") then 
			bonus.count = bonus.count + 1
			Objective_SetCounter(bonus, bonus.count, bonus.threshold)
		end
	end
end


-----------------------------------------------------------------------
-- Recover supplies bonus objective
-----------------------------------------------------------------------

function Skirmish_StartSupplies(context, data)
	if not bonus then

		-- Find a spot in enemy territory away from player's squads so marker smoke isn't visible
		local markers = Skirmish_GetMarkers("mkr_supplies", local_player, true)
		local marker = markers[World_GetRand(1, #markers)]
		if Event_IsAnyRunning() or Prox_ArePlayersNearMarker(local_player, marker, ANY, 40, nil, nil, true) then
			Rule_AddOneShot(Skirmish_StartSupplies, 10, nil, bonus_rule)
			return
		end

		-- Drop supplies
		Skirmish_Unlock(allied_player, "airborne_left_2a_supply_drop_us", ABILITY.AMERICAN.AIRBORNE_LEFT_2B_SUPPLY_DROP_US)
		local pos = Marker_GetPosition(marker)
		local dir = Util_GetDirectionFromAtoB(Player_GetStartingPosition(enemy_player), pos)
		Cmd_Ability(allied_player, ABILITY.AMERICAN.AIRBORNE_LEFT_2B_SUPPLY_DROP_US, pos, dir, true, true)

		Rule_AddOneShot(Skirmish_BonusSupplies, 6, {pos = pos}, bonus_rule)
	end
end


function Skirmish_BonusSupplies(context, data)
	if not bonus then
		-- Wait till all supplies dropped
		local eg = EGroup_CreateUnique() 
		World_GetEntitiesNearPoint(local_player, eg, data.pos, 50, OT_Ally)
		EGroup_Filter(eg, {EBP.AMERICAN.MUNITION_PARADROP_US, EBP.AMERICAN.MEDKIT_PARADROP_US}, FILTER_KEEP)
		if EGroup_Count(eg) < 1 then
			Rule_AddOneShot(Skirmish_BonusSupplies, 2, data, bonus_rule)
			EGroup_Destroy(eg)
		else
			bonus = {
				Title = _skirmish.narrative.event_supplies.obj_text,-- "Recover discarded munitions" 
				Type = OT_Bonus,
				threshold = EGroup_Count(eg),
				eg = eg,
				pos = data.pos,
				Intel_Start = function()
					CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_supplies.start)
					CTRL.WAIT()
				end,
				Intel_Fail = function()
					CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_supplies.fail)
					CTRL.WAIT()
				end,
				OnStart = function()
					Skirmish_CreateMapBlip(bonus, bonus.eg)
					Rule_AddGlobalEvent(Skirmish_OnPickupSupplies, GE_SquadItemPickup)
				end,
			}
			Objective_Register(bonus)
			Objective_SetCounter(bonus, 0, EGroup_Count(eg))
			Objective_Start(bonus, true, true)
			
			-- Prevent enemy from recovering supplies too quickly
			Player_SetCommandAvailability(enemy_player, SCMD_PickUpSimItem, ITEM_REMOVED)
			Rule_AddOneShot(Skirmish_EnableEnemyItemPickup, Scale({5,4,3.5,3,2})*60, nil, bonus_rule)
		end
	end
end


-- Rule that (re)enables enemy player's squads to pick up items
function Skirmish_EnableEnemyItemPickup(context, data)
	Player_SetCommandAvailability(enemy_player, SCMD_PickUpSimItem, ITEM_UNLOCKED)
end


-- Global event callback for GE_SquadItemPickup
function Skirmish_OnPickupSupplies(context)
	if bonus and not Objective_IsComplete(bonus) and  World_DistancePointToPoint(Entity_GetPosition(context.entity), bonus.pos) < 20 then
		local ebp = BP_GetEntityBlueprintByPbgID(context.item.PropertyBagGroupID)
		if ebp == EBP.AMERICAN.MUNITION_PARADROP_US or ebp == EBP.AMERICAN.MEDKIT_PARADROP_US then
			if Squad_GetPlayerOwner(context.squad) == enemy_player then
				bonus.threshold = bonus.threshold - 1
				Objective_SetCounter(bonus, 0, bonus.threshold)
			end
			local remaining = EGroup_Count(bonus.eg)
			Obj_SetCounterCount(bonus.ID, bonus.threshold - remaining)
			if remaining == 0 then
				Skirmish_RemoveMapBlips(bonus)
				EGroup_Destroy(bonus.eg)
				Rule_RemoveGlobalEvent(Skirmish_OnPickupSupplies)
				if Squad_GetPlayerOwner(context.squad) == local_player then
					Rule_AddOneShot(Skirmish_CompleteBonusObjective, 3.0)
				else
					Objective_Fail(bonus)
				end
			end
		end
	end
end


-----------------------------------------------------------------------
-- Protect VIP bonus objective
-----------------------------------------------------------------------


function Skirmish_StartVIP()
	if not Rule_Exists(Skirmish_BonusVIP) then 
		Rule_AddGlobalEvent(Skirmish_BonusVIP, GE_SquadProductionQueue)
	end
end


-- Global event callback for GE_SquadProductionQueue - triggers when a squad is reinforced.
function Skirmish_BonusVIP(context)
	local squad = context.squad
	if not World_OwnsSquad(squad) 
		and Squad_GetPlayerOwner(squad) == Game_GetLocalPlayer() 
		and Squad_GetBlueprint(squad) == basic_infantry_sbp[Player_GetRaceName(Game_GetLocalPlayer())]
		and Squad_GetVeterancyRank(squad) < 2 then
		if not Event_IsAnyRunning() then
			Rule_RemoveGlobalEvent(Skirmish_BonusVIP)
			if not bonus then  
				--local ui_info = BP_GetSquadUIInfo(Squad_GetBlueprint(squad), Player_GetRace(Game_GetLocalPlayer()))
				bonus = {
					Title = _skirmish.narrative.event_vip.obj_text,-- "Promote rifleman squad to rank 3"
					Type = OT_Bonus,
					squad = squad,
					Intel_Start = function()
						CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_vip.start)
						CTRL.WAIT()
					end,
					OnStart = function()
						Skirmish_CreateMapBlip(bonus, bonus.squad)
						UI_CreateMinimapBlip(Util_GetPosition(bonus.squad), 10, "objective_secondary")
					end,
					IsComplete = function()
						if Squad_IsAlive(bonus.squad) and Squad_GetVeterancyRank(bonus.squad) == 3 then
							Skirmish_RemoveMapBlips(bonus)
							return true
						end
					end,
					IsFailed = function()
						if not Squad_IsAlive(bonus.squad) then
							Skirmish_RemoveMapBlips(bonus)
							return true
						end
					end,
					Intel_Complete = function()
						CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_vip.done)
						CTRL.WAIT()
					end,
					Intel_Fail = function()
						CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_vip.fail)
						CTRL.WAIT()
					end,
				}
				if Player_GetRace(local_player) == RACE.BRITISH then
					bonus.Title = 11222566		-- Promote infantry squad to rank 3
				end
				
				Objective_Register(bonus)
				Objective_Start(bonus, true, true)
				Objective_AddUIElements(bonus, squad, true, Loc_Empty(), true, 2.0, nil, HPAT_Bonus, "icons/objectives/objective_bonus", "BonusObjectiveDataTemplate")
			end
		end
	end
end

-----------------------------------------------------------------------
-- Sniper hunt bonus objective
-----------------------------------------------------------------------


function Skirmish_StartSniper()
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_StartSniper, 10, nil, bonus_rule)
	elseif not bonus then
		-- Get potential hiding spots
		local sg = Player_GetSquads(Game_GetLocalPlayer())
		local buildings = {}
		local eg = EGroup_CreateUnique()
		local mkr_sniper = Skirmish_GetMarkers("mkr_sniper", local_player)
		local radius = 50
		if mkr_sniper then
			radius = Marker_GetProximityRadiusOrDefault(mkr_sniper, 90)
		else
			mkr_sniper = Util_ScarPos(0,0)
		end
		World_GetEntitiesNearPoint(local_player, eg, Marker_GetPosition(mkr_sniper), radius, OT_Neutral)
		EGroup_ForEach(eg, 
			function(egroup, index, entity)
				if Entity_CanLoadSquad(entity, SGroup_GetSpawnedSquadAt(sg, 1), true, true) 
					and World_GetInteractionStageAtPoint(Entity_GetPosition(entity)) == 0 
					and not Player_CanSeeEntity(local_player, entity) then
					table.insert(buildings, entity)
				end
			end)
		if #buildings > 2 then
			--local hideout = buildings[World_GetRand(1, #buildings)]
			--while #buildings > 5 do
			--local i = World_GetRand(1, #buildings)
			--if hideout ~= buildings[i] then
			--table.remove(buildings, i)
			--end
			--end
			buildings = Table_GetRand(buildings, math.min(5, #buildings))
			local hideout = Table_GetRandomItem(buildings, 1)
			
			local sg_sniper = SGroup_CreateUnique()
			local eg_building = EGroup_CreateUnique()
			EGroup_Add(eg_building, hideout)
			local sniper = Squad_CreateAndSpawnToward(SBP.GERMAN.SNIPER_GER, enemy_player, 1, Entity_GetPosition(hideout), Entity_GetPosition(hideout))
			AI_LockSquad(enemy_player, sniper)
			SGroup_Add(sg_sniper, sniper)
			Squad_IncreaseVeterancyRank(sniper, 1, true)
			Squad_IncreaseVeterancyRank(sniper, 1, true)
			Squad_IncreaseVeterancyRank(sniper, 1, true)
			Modifier_ApplyToEntity(Modifier_Create(MAT_Entity, "health_maximum_modifier", MUT_Multiplication, false, 2.0, ""), Squad_EntityAt(sniper, 0), 0)
			Cmd_Garrison(sg_sniper, eg_building, nil, nil, true)
			Cmd_UngarrisonSquad(sg_sniper, nil, true)
			Rule_AddOneShot(Skirmish_HideSniper, 2, { sg_sniper = sg_sniper }, bonus_rule)
			EGroup_Destroy(eg_building)	
			
			bonus = {	
				Title = _skirmish.narrative.event_sniper.obj_text,--"Find and kill the veteran sniper" 
				Type = OT_Bonus,
				sg = sg_sniper,
				squad = sniper,
				buildings = buildings,
				hideout = hideout,
				radius = radius,
				Intel_Start = function()
					CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_sniper.start)
					CTRL.WAIT()
				end,
				OnStart = function()
					bonus.blip = UI_CreateMinimapBlipOnPosFrom(enemy_player, 
						Prox_GetRandomPosition(Entity_GetPosition(bonus.hideout), bonus.radius / 2, bonus.radius / 5),
						-1, "BonusObjectiveDataTemplate", bonus.radius * 0.65)
				end,
				IsComplete = function() 
					return not Squad_IsAlive(bonus.squad) or (#bonus.buildings > 0 and (bonus.hideout == nil or Entity_GetHealth(bonus.hideout) <= 0))
				end,
				OnComplete = function()
					if Rule_Exists(Skirmish_HuntSniper) then
						Rule_RemoveGlobalEvent(Skirmish_HuntSniper)
					end
					--for i = #bonus.buildings, 1, -1 do
					--UI_DeleteMinimapBlip(bonus.blips[i])
					--table.remove(bonus.blips, i)
					--table.remove(bonus.buildings, i)
					--end
					UI_DeleteMinimapBlip(bonus.blip)
					SGroup_Destroy(bonus.sg)
				end,
				--TODO: Fail if X units killed by sniper?
			}
			Objective_Register(bonus)
			Objective_Start(bonus, true, true)
			--bonus.blips = {}
			--for i = 1, #buildings do
			--table.insert(bonus.blips, UI_CreateMinimapBlip(buildings[i], -1, "BonusObjectiveDataTemplate"))
			--end
			--bonus.blip = UI_CreateMinimapBlip(Prox_GetRandomPosition(Entity_GetPosition(hideout), radius/2, radius/5), -1, "BonusObjectiveDataTemplate", radius * 0.65)
			Rule_AddGlobalEvent(Skirmish_HuntSniper, GE_GarrisonSquad)
		else
			-- Most likely player squads were in vicinity - try again later
			Rule_AddOneShot(Skirmish_StartSniper, 15, nil, bonus_rule)
		end
	end
end



function Skirmish_HideSniper(context, data)
	SGroup_DeSpawn(data.sg_sniper)
end


-- Global event callback for GE_GarrisonSquad.
function Skirmish_HuntSniper(context)--context.hold (entity) context.squad	
	if bonus and bonus.buildings then
		if context.loading 
			and context.squad 
			and not World_OwnsSquad(context.squad)
			and Squad_GetPlayerOwner(context.squad) == Game_GetLocalPlayer() then
			if context.hold == bonus.hideout then
				UI_DeleteMinimapBlip(bonus.blip)
				Rule_RemoveGlobalEvent(Skirmish_HuntSniper)
				Squad_Spawn(bonus.squad, Squad_GetPositionDeSpawned(bonus.squad), "")
				AI_UnlockSquad(Squad_GetPlayerOwner(bonus.squad), bonus.squad)
				Cmd_Retreat(bonus.sg)
				Sound_Play3D("warning_sniper", Squad_EntityAt(context.squad, 0))
			end
		end
	else
		Rule_RemoveGlobalEvent(Skirmish_HuntSniper)
	end
end

-----------------------------------------------------------------------
-- Tank hunt bonus objective
-----------------------------------------------------------------------

-- Adds bonus objective ("Destroy enemy Panther before it reaches rank 1") when player produces a tank. 
function Skirmish_StartPanther()
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_StartPanther, 2.0, nil, bonus_rule)
		return
	end
	if not bonus then
		local start = Player_GetStartingPosition(enemy_player)
		local facing = Util_GetDirectionFromAtoB(start, World_Pos(0,0,1))
		local pos = World_GetOffsetPosition(start, facing, OFFSET_FRONT, 12.0)
		local squad = Squad_CreateAndSpawnToward(SBP.GERMAN.PANTHER_GER, enemy_player, 0, pos, facing)
		Squad_CompleteUpgrade(squad, BP_GetUpgradeBlueprint("sp_disable_immune"))
		local h = Entity_GetHealthMax(Squad_EntityAt(squad, 0))
		Modifier_ApplyToEntity(Modifier_Create(MAT_Entity, "health_maximum_modifier", MUT_Multiplication, false, Scale({h/h, 900/h, 1000/h, 1150/h, 1300/h}), ""), Squad_EntityAt(squad, 0), 0)
		bonus = {
			Title = _skirmish.narrative.event_panzer.obj_text, 
			Type = OT_Bonus,
			squad = squad,
			Intel_Start = function()
				CTRL.Event_Delay(5)
				CTRL.WAIT()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_panzer.start)
				CTRL.WAIT()
			end,
			OnStart = function()
				Skirmish_CreateMapBlip(bonus, bonus.squad)
				UI_CreateMinimapBlip(Util_GetPosition(bonus.squad), 10, "objective_secondary")
			end,
			IsComplete = function() 
				return not Squad_IsAlive(bonus.squad) 
			end,
			IsFailed = function()
				if Squad_IsAlive(bonus.squad) and Squad_GetVeterancyRank(bonus.squad) >= 1 then
					Skirmish_RemoveMapBlips(bonus)
					return true
				end
			end,
		}
		Objective_Register(bonus)
		Objective_Start(bonus, true, true)
	end
end

-----------------------------------------------------------------------
-- Destroy convoy bonus objective 
-----------------------------------------------------------------------


function Skirmish_StartConvoy()
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_StartConvoy, 2.0, nil, bonus_rule)
		return
	end
	if not bonus then
		local enemy_entry_points = Skirmish_GetMarkers("mkr_entry", enemy_player, true)
		Rule_AddOneShot(Skirmish_SpawnConvoy, 1, {
			player = enemy_player,
			start_pos = Marker_GetPosition(enemy_entry_points[3]),	-- Use entry point furthest from base
			end_pos = Marker_GetPosition(Marker_FromName("mkr_base_".._skirmish.enemy_base, "")),
			sg = SGroup_CreateUnique(),
			sbps = {
				SBP.GERMAN.PANZER_IV_GER,
				SBP.GERMAN.PANZER_IV_GER,
				SBP.GERMAN.PANZER_IV_CMD_GER,
			}
		}, bonus_rule)
	end
end


function Skirmish_SpawnConvoy(context, data)
	local squad = Squad_CreateAndSpawnToward(data.sbps[#data.sbps], data.player, 0, data.start_pos, Util_GetDirectionFromAtoB(data.start_pos, data.end_pos))
	SGroup_Add(data.sg, squad)
	AI_LockSquad(data.player, squad)
	Squad_CompleteUpgrade(squad, BP_GetUpgradeBlueprint("sp_disable_immune"))

	local min = Scale(25, 60, math.floor)
	local max = min + Scale(10, 25, math.floor)

	Squad_SetHealth(squad, World_GetRand(min, max) / 100.0)

	local modifier = Modifier_Create(MAT_Entity, "speed_maximum_modifier", MUT_Set, true, 1.5, "")
	Modifier_AddToSquadTable(squad, Modifier_ApplyToSquad(modifier, squad, 0))

	modifier = Modifier_Create(MAT_Entity, "rotation_rate_modifier", MUT_Set, true, 0.5, "")
	Modifier_AddToSquadTable(squad, Modifier_ApplyToSquad(modifier, squad, 0))

	modifier = Modifier_Create(MAT_Weapon, "horizontal_speed_weapon_modifier", MUT_Multiplication, false, 0.4, 1)
	Modifier_AddToSquadTable(squad, Modifier_ApplyToSquad(modifier, squad, 0))
	
	--StateTree_QueueGlobalStateTreeEntity(false, "trigger_critical_engine", Squad_EntityAt(squad, 0))

	local sg = SGroup_CreateUnique()
	SGroup_Add(sg, squad)
	Cmd_SquadPath(sg, "path_convoy_".._skirmish.enemy_base, true, LOOP_NONE, false, 0.0, nil, false, true, 3.0)

	table.remove(data.sbps, #data.sbps)
	if #data.sbps > 0 then 
		Rule_AddOneShot(Skirmish_SpawnConvoy, 8.0, data, bonus_rule)
	else
		Rule_AddOneShot(Skirmish_BonusConvoy, 0.25, data, bonus_rule)
	end
end


function Skirmish_KickstartConvoy()
	if bonus and bonus.sg and SGroup_CountSpawned(bonus.sg) > 0 then 
		Cmd_SquadPath(bonus.sg, "path_convoy_".._skirmish.enemy_base, true, LOOP_NONE, false, 0.0, nil, false, true, 3.0)
	end
end

function Skirmish_BonusConvoy(context, data)
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_BonusConvoy, 2.0, data, bonus_rule)
		return
	end
	
	if not bonus then
		bonus = {
			Title = _skirmish.narrative.event_convoy.obj_text,-- "Destroy enemy tanks returning to base" 
			Type = OT_Bonus,
			sg = data.sg,
			target = data.end_pos,
			total = SGroup_CountSpawned(data.sg),
			Intel_Start = function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_convoy.start)
				CTRL.WAIT()
			end,
			OnStart = function()			
				Skirmish_CreateMapBlip(bonus, bonus.sg)
				WaypointPath_Show("path_convoy_".._skirmish.enemy_base)
				UI_CreateMinimapBlip(Util_GetPosition(bonus.sg), 10, "objective_secondary")
				Rule_AddSGroupEvent(Skirmish_KilledConvoy, bonus.sg, GE_SquadKilled, bonus)
				Rule_AddInterval(Skirmish_KickstartConvoy, 10)
			end,
			IsComplete = function()				
				Objective_SetCounter(bonus, bonus.total - SGroup_CountSpawned(bonus.sg), bonus.total)
				if SGroup_CountSpawned(bonus.sg) == 0 then
					WaypointPath_Hide("path_convoy_".._skirmish.enemy_base)
					Rule_Remove(Skirmish_KickstartConvoy)
					Rule_RemoveSGroupEvent(Skirmish_KilledConvoy, bonus.sg)
					SGroup_Destroy(bonus.sg)				
					return true
				end 
			end,
			IsFailed = function()				
				if SGroup_CountSpawned(bonus.sg) > 0 and Util_GetDistanceSquared(SGroup_GetPosition(bonus.sg), bonus.target) < 600 then
					WaypointPath_Hide("path_convoy_".._skirmish.enemy_base)
					Rule_Remove(Skirmish_KickstartConvoy)
					Skirmish_RemoveMapBlips(bonus)
					AI_UnlockSquads(Squad_GetPlayerOwner(SGroup_GetSquadAt(bonus.sg, 1)), bonus.sg)
					Modifier_RemoveAllFromSGroup(bonus.sg)
					Rule_RemoveSGroupEvent(Skirmish_KilledConvoy, bonus.sg)
					SGroup_Destroy(bonus.sg)
					return true
				end
			end,
		}
		Objective_Register(bonus)
		Objective_SetCounter(bonus, 0, bonus.total)
		Objective_Start(bonus, true, true)
	end
end


-- Global event callback for GE_EntityKilled.
-- Maintains map blip on a squad in the convoy.
function Skirmish_KilledConvoy(context, data)
	if SGroup_CountSpawned(data.sg) > 0 then
		Skirmish_RemoveMapBlips(data)
		Skirmish_CreateMapBlip(data, data.sg)
	end
end
	

-----------------------------------------------------------------------
-- Capture Panzerschreck bonus objective 
-----------------------------------------------------------------------


-- Global event callback for GE_ConstructionComplete 
function Skirmish_StartPanzerschreck(context)
	if not bonus then
		if context and context.pbg then
			if context.player == enemy_player and context.pbg == EBP.GERMAN.MECHANIZED_KOMPANIE_GER then
				if Rule_Exists(Skirmish_StartPanzerschreck) then 
					Rule_RemoveGlobalEvent(Skirmish_StartPanzerschreck)	
				end
				Skirmish_BonusPanzerschreck()
			end
		else
			local eg = Player_GetEntities(enemy_player)
			EGroup_Filter(eg, EBP.GERMAN.MECHANIZED_KOMPANIE_GER, FILTER_KEEP)
			if EGroup_Count(eg) > 0 then
				Skirmish_BonusPanzerschreck()
			else--if not Rule_Exists(Skirmish_StartPanzerschreck) then
				-- HACK: The AI doesn't reliably build a EBP.GERMAN.MECHANIZED_KOMPANIE_GER, so just build it for them
				--Rule_AddGlobalEvent(Skirmish_StartPanzerschreck, GE_ConstructionComplete)
				local ebp = EBP.GERMAN.MECHANIZED_KOMPANIE_GER
				local pos = Entity_FindConstructionLocation(enemy_player, ebp, Player_GetStartingPosition(enemy_player), 100, 5)
				local entity = Entity_CreateFacing(ebp, enemy_player, pos, Util_ScarPos(0,0), true)
				Entity_Spawn(entity)
				Entity_ForceConstruct(entity)
				World_UpdatePathfindingBlockers()
				Skirmish_BonusPanzerschreck()
			end
			EGroup_Destroy(eg)
		end
	end
end


function Skirmish_BonusPanzerschreck()
	if not bonus then
		bonus = {
			squad_ids = {},
			Title = _skirmish.narrative.event_schreck.obj_text,-- "Capture a Panzerschreck" 
			Type = OT_Bonus,
			Intel_Start = function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_schreck.start)
				CTRL.WAIT()
			end,
			OnComplete = function()
				Rule_RemoveGlobalEvent(Skirmish_SpawnJaeger)	
				Rule_RemoveGlobalEvent(Skirmish_CapturePanzerschreck)
				Rule_RemoveGlobalEvent(Skirmish_OnUpgradeSetPanzerschreckDropRate)
				Skirmish_RemoveMapBlips(bonus)
			end,
		}
		Objective_Register(bonus)
		Objective_Start(bonus, true, true)
		Rule_AddGlobalEvent(Skirmish_SpawnJaeger, GE_SquadKilled)
		Rule_AddGlobalEvent(Skirmish_CapturePanzerschreck, GE_SquadItemPickup)
		Rule_AddGlobalEvent(Skirmish_OnUpgradeSetPanzerschreckDropRate, GE_UpgradeComplete)
		Skirmish_SpawnJaeger()
	end	
end


-- Global event callback for GE_SquadKilled
-- Spawns a Jaeger squad equipped with a panzerschreck
function Skirmish_SpawnJaeger(context)
	if not context or Squad_GetBlueprint(context.victim) == SBP.GERMAN.JAEGER_GER then
		local sg = SGroup_CreateUnique()
		local squad = Squad_CreateAndSpawnToward(SBP.GERMAN.JAEGER_GER, enemy_player, 0, Player_GetStartingPosition(enemy_player), Util_ScarPos(0,0))
		SGroup_Add(sg, squad)
		Cmd_InstantUpgrade(sg, BP_GetUpgradeBlueprint("panzerschrek_jaeger_ger"))
		SGroup_Destroy(sg)
	end
end


-- Global event callback for GE_UpgradeComplete
function Skirmish_OnUpgradeSetPanzerschreckDropRate(context)
	if scartype(context.executer) == ST_SQUAD and Squad_GetPlayerOwner(context.executer) == enemy_player and context.upgrade == BP_GetUpgradeBlueprint("panzerschrek_jaeger_ger") then
		table.insert(bonus.squad_ids, Squad_GetID(context.executer))
		if not Rule_Exists(Skirmish_DelayedSetWeaponDropRate) then
			Rule_AddOneShot(Skirmish_DelayedSetWeaponDropRate, 0.5)
		end
	end
end


function Skirmish_DelayedSetWeaponDropRate()
	for _, squad_id in pairs(bonus.squad_ids) do
		if Squad_IsValid(squad_id) then 
			local squad = Squad_FromID(squad_id)
			for _, weapon in pairs(Squad_GetAttachedWeapons(squad)) do
				Squad_OverrideItemDropChance(squad, weapon, 1.0)
			end
		end
	end
	bonus.squad_ids = {}
end


-- Global event callback for GE_SquadItemPickup
-- Completes bonus objective when player's squad picks up a panzerschreck
function Skirmish_CapturePanzerschreck(context)
	if bonus and not Objective_IsComplete(bonus) and context.item == EBP.GERMAN.W_PANZERSCHREK_STORMTROOPER_GER and Squad_GetPlayerOwner(context.squad) == Game_GetLocalPlayer() then
		Rule_AddOneShot(Skirmish_CompleteBonusObjective, 3.0)
	end
end


-- Delayed objective completion
function Skirmish_CompleteBonusObjective(context, data)
	if bonus and not Objective_IsComplete(bonus) then
		Objective_Complete(bonus, true, true)
	end
end


-----------------------------------------------------------------------
-- Destroy artillery battery bonus objective
-----------------------------------------------------------------------


function Skirmish_StartBattery()
	if not bonus then
		local battery_markers = Skirmish_GetMarkers("mkr_battery", local_player, true)
		local marker = battery_markers[World_GetRand(1, #battery_markers)]
		local pos = Marker_GetPosition(marker)
		local point = Territory_GetSectorCreatorEntity(Territory_FindClosestSectorToPoint(pos))
		if World_OwnsEntity(point) or Entity_GetPlayerOwner(point) ~= enemy_player or Player_CanSeePosition(local_player, pos) then 
			Rule_AddOneShot(Skirmish_StartBattery, 15, nil, bonus_rule)
		else
			local squad = Squad_CreateAndSpawnToward(SBP.GERMAN.HOWITZER_CANNONE_DA_105_GER, enemy_player, 0, pos, Util_GetDirectionFromAtoB(pos, Util_ScarPos(0,0)))
			Squad_SetRecrewable(squad, false)
			--AI_LockSquad(enemy_player, squad)
			Player_SetPopCapOverride(enemy_player, Player_GetPopCapOverride(enemy_player) + Squad_Population(squad, CT_Personnel))
			local sg = SGroup_CreateUnique()
			SGroup_Add(sg, squad)
			Rule_AddOneShot(Skirmish_FireBattery, 1, {squad_id = Squad_GetID(squad), sg = sg}, bonus_rule)
			
			-- Scatter some mines nearby
			local offsets = {OFFSET_FRONT, OFFSET_FRONT_RIGHT, OFFSET_FRONT_LEFT}
			local facing = Util_GetDirectionFromAtoB(pos, Player_GetStartingPosition(local_player))
			for i = 1, #offsets do
				if World_GetRand(1,2) == 1 then
					local mine_pos = Prox_GetRandomPosition(World_GetOffsetPosition(pos, facing, offsets[i], 12.0), 8, 5)
					local mine = Entity_Create(EBP.GERMAN.MINE_PIONEER_GER, enemy_player, mine_pos, true)
					Entity_WarpToPos(mine, World_GetSpawnablePosition(mine_pos, mine))
					Entity_Spawn(mine)
					Entity_ForceConstruct(mine)
				end
			end

			-- Defending infantry
			AI_Enable(unused_player, true)
			local sbps = {SBP.GERMAN.GRENADIER_GER, SBP.GERMAN.PANZERGRENADIER_GER, SBP.GERMAN.JAEGER_GER}
			for i = 1, Scale(1,3,math.round) do
				Util_CreateSquads(unused_player, nil, sbps[World_GetRand(1,#sbps)], Prox_GetRandomPosition(pos, 16, 10))
			end
			local ai_prefab = AI_AddPrefab(unused_player, "Defend_Artillery", "Defend", 30, 1, 3, false, true)
			AI_SetPrefabTarget_Position(ai_prefab, unused_player, pos)

			-- Random artillery
			Rule_AddOneShot(Skirmish_InitArtillery, 10, { artillery = Scale({1,1,2,3,4})}, mission_rule)
		end
	end
end

function Skirmish_FireBattery(context, data)
	if Squad_IsValid(data.squad_id) then
		local artillery = Squad_FromID(data.squad_id)
		local sg_targets = Player_GetSquads(local_player)
		SGroup_FilterSpawned(sg_targets, FILTER_KEEP)
		SGroup_Filter(sg_targets, {"building", "base_defense", "auto_builder", "airplane"}, FILTER_REMOVE)
		local target
		local min_squad_count = Scale(4,1, math.floor)
		local min_squad_size = Scale(4,1, math.floor)
		if SGroup_CountSpawned(sg_targets) >= min_squad_count then
			local start = Player_GetStartingPosition(local_player)
			SGroup_ForEach(sg_targets, function(sgroup, index, squad)
					if Squad_Count(squad) > min_squad_size then 
						local pos = Squad_GetPosition(squad)
						local distance_to_target = World_DistancePointToPoint(pos, Squad_GetPosition(artillery))
						if distance_to_target > 35
							and distance_to_target < 260
							and World_DistancePointToPoint(start, Squad_GetPosition(squad)) > 80 then
							target = pos
							return true
						end 
					end
				end)
		end
		local min_scatter = Scale(6, 2, math.floor)
		local max_scatter = Scale(15,7, math.floor)
		if target then
			Player_ResetAbilityCooldowns(Squad_GetPlayerOwner(artillery), ABILITY.GERMAN.BARRAGE_HOWITZER_CANNONE_105_GER)
			Cmd_Ability(data.sg, ABILITY.GERMAN.BARRAGE_HOWITZER_CANNONE_105_GER, Prox_GetRandomPosition(target, max_scatter, min_scatter), Util_GetDirectionFromAtoB(Squad_GetPosition(artillery), target), true, false)
			if not bonus then 
				Rule_AddOneShot(Skirmish_BonusBattery, 20, data, bonus_rule)
			end
		end
		local min_wait = Scale(40, 20, math.floor)
		local max_wait = min_wait + Scale(30, 10, math.floor)
		Rule_AddOneShot(Skirmish_FireBattery, World_GetRand(min_wait, max_wait), data, bonus_rule)
	end
end


--Add bonus objective after artillery first fires
function Skirmish_BonusBattery(context, data)
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_BonusBattery, 4, data, bonus_rule)
		return
	end
	if not bonus then
		bonus = {
			Title = _skirmish.narrative.event_battery.obj_text,--"Eliminate enemy artillery battery" 
			Type = OT_Bonus,
			Intel_Start = function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_battery.start)
				CTRL.WAIT()
			end,
			sg = data.sg,
			OnStart = function()
				Skirmish_CreateMapBlip(bonus, bonus.sg)
			end,
			IsComplete = function()
				return SGroup_CountSpawned(bonus.sg) == 0 
			end,
			OnComplete = function()
				if Rule_Exists(Skirmish_FireBattery) then
					Rule_Remove(Skirmish_FireBattery)
				end
				if Rule_Exists(Skirmish_DoArtilleryStrike) then
					Rule_Remove(Skirmish_DoArtilleryStrike)
				end
				SGroup_Destroy(bonus.sg)
			end,
		}
		Objective_Register(bonus)
		Objective_Start(bonus, true, true)
	end
end

-----------------------------------------------------------------------
-- Kill veteran panzergrenadier squad bonus objective 
-----------------------------------------------------------------------

function Skirmish_StartVeteran()
	if not Rule_Exists(Skirmish_BonusVeteran) then
		Rule_AddGlobalEvent(Skirmish_BonusVeteran, GE_SquadVeterancyRank)
	end	
end


-- Callback for GE_SquadVeterancyRank. Add bonus objective for killing vet squad
function Skirmish_BonusVeteran(context)
	local sbp = Squad_GetBlueprint(context.squad)
	local rank = Squad_GetVeterancyRank(context.squad)
	if rank > 1 and Player_ObserveRelationship(context.player, Game_GetLocalPlayer()) == R_ENEMY and sbp == SBP.GERMAN.PANZERGRENADIER_GER then
		if not bonus then
			Rule_RemoveGlobalEvent(Skirmish_BonusVeteran)		--TODO: Make objective about killing ALL PzGren squads that reaches vet 2 during lifetime of bonus obj (use counter)
			bonus = {
				Title = _skirmish.narrative.event_veteran.obj_text, -- "Kill veteran panzergrenadiers before they reach rank 3"
				Type = OT_Bonus,
				squad = context.squad,
				Intel_Start = function()
					CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_veteran.start)
					CTRL.WAIT()
				end,
				OnStart = function()				
					Skirmish_CreateMapBlip(bonus, bonus.squad)
					UI_CreateMinimapBlip(Util_GetPosition(bonus.squad), 10, "objective_secondary")
				end,
				IsComplete = function()
					return not Squad_IsAlive(bonus.squad) 
				end,
				OnComplete = function()
					Skirmish_RemoveMapBlips(bonus)
				end,
				IsFailed = function()
					return Squad_IsAlive(bonus.squad) and Squad_GetVeterancyRank(bonus.squad) >= 3
				end,
				OnFail = function()
					Skirmish_RemoveMapBlips(bonus)
					local sg = Player_GetSquads(Squad_GetPlayerOwner(bonus.squad))
					SGroup_Filter(sg, Squad_GetBlueprint(bonus.squad), FILTER_KEEP)
					SGroup_ForEach(sg, function(sgroup, index, squad)
							Squad_IncreaseVeterancyRank(squad, 1, true)
						end)
					SGroup_Destroy(sg)
				end,
			}
			Objective_Register(bonus)
			Objective_Start(bonus, true, true)
		end
	end
end


-----------------------------------------------------------------------
-- Inspection bonus objective 
-----------------------------------------------------------------------

function Skirmish_StartInspection()
	if not bonus then
		local player = Game_GetLocalPlayer()
		local start = Player_GetStartingPosition(player)
		
		-- Ensure player owns a couple fuel and munition points plus at least one vet 1 rifleman squad 
		local eg = EGroup_CreateUnique()
		local fuel_points = {}
		local munition_points = {}
		World_GetStrategyPoints(eg, false)
		EGroup_ForEach(eg, function(egroup, i, entity)
				if not World_OwnsEntity(entity) and Entity_GetPlayerOwner(entity) == player then
					if Entity_IsOfType(entity, "resource_point_fuel") then
						table.insert(fuel_points, entity)
					elseif Entity_IsOfType(entity, "resource_point_munition") then
						table.insert(munition_points, entity)
					end
				end
			end)	
		EGroup_Destroy(eg)
		
		local veteran_squad
		local sg = Player_GetSquads(player)
		SGroup_Filter(sg, "infantry", FILTER_KEEP)
		SGroup_ForEach(sg, function(sgroup, index, squad)
			if Squad_GetVeterancyRank(squad) >= 1 then
				veteran_squad = squad
				return true
			end
		end)
		SGroup_Destroy(sg)
		
		if #fuel_points < 2 or #munition_points < 2 or not veteran_squad then
			Rule_AddOneShot(Skirmish_StartInspection, 20, nil, bonus_rule)
			return
		end
		local _SortByDistanceFromBase = function(a, b)
			return Util_GetDistanceSquared(a, start) < Util_GetDistanceSquared(b, start)
		end
		table.sort(fuel_points, _SortByDistanceFromBase)
		table.sort(munition_points, _SortByDistanceFromBase)
		
		-- Spawn a 4x4 truck to represent the General 
		local pos
		if Player_HasMapEntryPosition(player) then
			pos = Player_GetMapEntryPosition(player)
		else
			pos = World_GetOffsetPosition(start, Util_GetDirectionFromAtoB(start, Util_ScarPos(0,0)), OFFSET_FRONT, 40)
		end
		local squad = Squad_CreateAndSpawnToward(SBP.AMERICAN.TRUCK_4x4_US, player, 0, pos, pos)
		local sg = SGroup_CreateUnique()
		SGroup_Add(sg, squad)
		Cmd_Move(sg, start)
		
		-- Make inspector a bit more durable 
		local modifier = Modifier_Create(MAT_Entity, "health_maximum_modifier", MUT_Multiplication, false, 1.3, "")
		Modifier_ApplyToEntity(modifier, Squad_EntityAt(squad, 0), 0)
		
		
		bonus = {
			Title = _skirmish.narrative.event_inspection.obj_text,	-- "General inspection",
			Type = OT_Bonus,
			squad = squad,
			sg = sg,
			Intel_Start = function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_inspection.start)
				CTRL.WAIT()
			end,
			Intel_Complete = function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_inspection.done)
				CTRL.WAIT()
			end,
			Intel_Fail = function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_inspection.fail)
				CTRL.WAIT()
			end,
			OnStart = function()					
				Objective_AddUIElements(bonus, bonus.squad, true, Loc_Empty(), true, 2.0, nil, HPAT_Bonus, "icons/objectives/objective_bonus", "BonusObjectiveDataTemplate")
				Skirmish_CreateMapBlip(bonus, bonus.squad)
				UI_CreateMinimapBlip(Util_GetPosition(bonus.squad), 10, "objective_secondary")
				Objective_Start(bonus_sub_1, true, true)
			end,
			IsFailed = function()
				return not Squad_IsAlive(bonus.squad)
			end	,
			OnFail = function()
				Skirmish_RemoveMapBlips(bonus)
				SGroup_Destroy(bonus.sg)
			end,
			OnComplete = function()
				Skirmish_RemoveMapBlips(bonus)
				SGroup_Destroy(bonus.sg)
			end,
		}
		bonus_sub_1 = {
			Title = _skirmish.narrative.event_inspection.sub1_text,-- "Inspect the munitions point",
			Type = OT_Bonus,
			Parent = bonus,
			squad = squad,
			target = Entity_GetPosition(munition_points[#munition_points]),
			Intel_Start = function()
				CTRL.Event_Delay(10)
				CTRL.WAIT()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_inspection.sub1_start)
				CTRL.WAIT()
			end,
			OnStart = function()
				Skirmish_CreateMapBlip(bonus_sub_1, bonus_sub_1.target)
				UI_CreateMinimapBlip(Util_GetPosition(bonus_sub_1.target), 10, "objective_secondary")
			end,
			IsComplete = function()
				return Squad_IsAlive(bonus_sub_1.squad) and Util_GetDistance(bonus_sub_1.squad, bonus_sub_1.target) < 5
			end,
			OnComplete = function()
				Skirmish_RemoveMapBlips(bonus_sub_1)
				Objective_Show(bonus_sub_1, false)
				Objective_Start(bonus_sub_2)
			end,
		}
		bonus_sub_2 = {
			Title = _skirmish.narrative.event_inspection.sub2_text,--"Return to HQ",
			Type = OT_Bonus,
			Parent = bonus,
			squad = squad,
			target = start,
			Intel_Start = function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_inspection.sub2_start)
				CTRL.WAIT()
			end,
			OnStart = function()
				Skirmish_CreateMapBlip(bonus_sub_2, bonus_sub_2.target)
				UI_CreateMinimapBlip(Util_GetPosition(bonus_sub_2.target), 10, "objective_secondary")
			end,
			IsComplete = function()
				return Squad_IsAlive(bonus_sub_2.squad) and Util_GetDistance(bonus_sub_2.squad, bonus_sub_2.target) < 14
			end,
			OnComplete = function()
				Skirmish_RemoveMapBlips(bonus_sub_2)
				Objective_Show(bonus_sub_2, false)
				Objective_Start(bonus_sub_3)
			end,
		}
		bonus_sub_3 = {
			Title = _skirmish.narrative.event_inspection.sub3_text,-- "Inspect the fuel point",
			Type = OT_Bonus,
			Parent = bonus,
			squad = squad,
			target = Entity_GetPosition(fuel_points[#fuel_points]),
			Intel_Start = function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_inspection.sub3_start)
				CTRL.WAIT()
			end,
			OnStart = function()
				Skirmish_CreateMapBlip(bonus_sub_3, bonus_sub_3.target)
				UI_CreateMinimapBlip(Util_GetPosition( bonus_sub_3.target), 10, "objective_secondary")
			end,
			IsComplete = function()
				return Squad_IsAlive(bonus_sub_3.squad) and Util_GetDistance(bonus_sub_3.squad, bonus_sub_3.target) < 5
			end,	
			OnComplete = function()
				Skirmish_RemoveMapBlips(bonus_sub_3)
				Objective_Show(bonus_sub_3, false)
				local veteran_squad
				local sg = Player_GetSquads(Game_GetLocalPlayer())
				SGroup_Filter(sg, "infantry", FILTER_KEEP)
				SGroup_ForEach(sg, function(sgroup, index, squad)
					if Squad_GetVeterancyRank(squad) >= 1 then
						veteran_squad = squad
						return true
					end
				end)
				SGroup_Destroy(sg)
				if veteran_squad then 
					bonus_sub_4.target = veteran_squad
					Objective_Start(bonus_sub_4)
				else
					Objective_Start(bonus_sub_5)
				end
			end,
		}
		bonus_sub_4 = {	
			Title = _skirmish.narrative.event_inspection.sub4_text,-- "Inspect the troops",
			Type = OT_Bonus,
			Parent = bonus,
			squad = squad,
			Intel_Start = function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_inspection.sub4_start)
				CTRL.WAIT()
			end,
			Intel_Fail = function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_inspection.sub4_fail)
				CTRL.WAIT()
			end,
			OnStart = function()
				Skirmish_CreateMapBlip(bonus_sub_4, bonus_sub_4.target)
				UI_CreateMinimapBlip(Util_GetPosition(bonus_sub_4.target), 10, "objective_secondary")
			end,
			IsComplete = function()
				return Squad_IsAlive(bonus_sub_4.squad) and Squad_IsAlive(bonus_sub_4.target) and Util_GetDistance(bonus_sub_4.squad, bonus_sub_4.target) < 4
			end,
			OnComplete = function()
				Skirmish_RemoveMapBlips(bonus_sub_4)
				Objective_Show(bonus_sub_4, false)
				if Squad_GetVeterancyRank(bonus_sub_4.squad) == 0 then
					Objective_Start(bonus_sub_5)
				end
			end,
			IsFailed = function()
				return not Squad_IsAlive(bonus_sub_4.target)
			end,
			OnFail = function()
				Objective_Show(bonus_sub_4, false)
				Objective_Start(bonus_sub_5)
			end,
		}	
		bonus_sub_5 = {
			Title = _skirmish.narrative.event_inspection.sub5_text,-- "Make the general a combat veteran",
			Type = OT_Bonus,
			Parent = bonus,
			squad = squad,
			Intel_Start = function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_inspection.sub5_start)
				CTRL.WAIT()
			end,
			IsComplete = function()
				return Squad_GetVeterancyRank(bonus_sub_5.squad) > 0
			end,
			OnComplete = function()
				Objective_Show(bonus_sub_5, false)
				Objective_Complete(bonus, true, true)
			end,
			IsFailed = function()
				return not Squad_IsAlive(bonus_sub_5.squad)
			end,
			OnFail = function()
				Objective_Show(bonus_sub_5, false)
			end,
		}		
		Objective_Register(bonus)
		Objective_Register(bonus_sub_1)
		Objective_Register(bonus_sub_2)
		Objective_Register(bonus_sub_3)
		Objective_Register(bonus_sub_4)
		Objective_Register(bonus_sub_5)
		Objective_Start(bonus, false, true)		
	end
end	

-----------------------------------------------------------------------
-- Capture AT gun bonus objective 
-----------------------------------------------------------------------

function Skirmish_StartAT()
	local eg = Player_GetEntities(enemy_player)
	local support_armory
	EGroup_ForEach(eg, function(egroup, i, entity)
			if Entity_GetBlueprint(entity) == EBP.GERMAN.SUPPORT_ARMORY_GER then 
				support_armory = entity
				return true
			end
		end)
	if support_armory then
		Skirmish_BonusAT({ player = enemy_player, entity = support_armory, pbg = EBP.GERMAN.SUPPORT_ARMORY_GER })
	elseif not Rule_Exists(Skirmish_BonusAT) then
		Rule_AddGlobalEvent(Skirmish_BonusAT, GE_ConstructionComplete)
	end	
end

function Skirmish_BonusAT(context)
	if context and context.player ~= Game_GetLocalPlayer() and context.pbg == EBP.GERMAN.SUPPORT_ARMORY_GER then
		if Rule_Exists(Skirmish_BonusAT) then
			Rule_RemoveGlobalEvent(Skirmish_BonusAT)
		end
		bonus = {
			Title = _skirmish.narrative.event_atgun.obj_text, -- "Capture an enemy anti-tank gun" 
			Type = OT_Bonus,
			Intel_Start = function()
				CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_atgun.start)
				CTRL.WAIT()
			end,
			OnStart = function()
				Rule_AddGlobalEvent(Skirmish_CaptureAT, GE_EntityRecrewed)
			end,
			OnComplete = function()
				Rule_RemoveGlobalEvent(Skirmish_CaptureAT)
			end,
			OnFail = function()
				Rule_RemoveGlobalEvent(Skirmish_CaptureAT)
			end,
		}
		Objective_Register(bonus)
		Objective_Start(bonus, true, true)
		
		--spawn enemy AT gun
		local pos = Entity_GetPosition(context.entity)
		local facing = Util_GetDirectionFromAtoB(pos, Util_ScarPos(0,0))
		Squad_CreateAndSpawnToward(SBP.GERMAN.AT_GUN_75MM_GER, context.player, 0, World_GetOffsetPosition(pos, facing, OFFSET_FRONT, 10.0), facing)
	end
end

function Skirmish_CaptureAT(context)
	if Entity_GetBlueprint(context.entity) == EBP.GERMAN.TW_AT_GUN_75MM_GER 
		and Entity_GetPlayerOwner(context.entity) ==  Game_GetLocalPlayer()
		and not Objective_IsComplete(bonus) then
		Objective_Complete(bonus, true, true)
	end
end

-----------------------------------------------------------------------
-- Field test AT gun bonus objective 
-----------------------------------------------------------------------

function Skirmish_StartFieldTest()
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_StartFieldTest, 4, nil, bonus_rule)
		return
	end

	--Spawn AT gun
	local sbp = SBP.AMERICAN.AT_GUN_57MM_US
	if Player_GetRace(local_player) == RACE.BRITISH then
		sbp = SBP.BRITISH.AT_GUN_6PDR_UK
	end
	local pos = Skirmish_GetMapEntryPosition(local_player)
	local facing = Util_GetDirectionFromAtoB(pos, Util_ScarPos(0,0))
	local squad = Squad_CreateAndSpawnToward(sbp, local_player, 0, pos, facing)
	local sg = SGroup_CreateUnique()
	SGroup_Add(sg, squad)
	Cmd_Move(sg, World_GetOffsetPosition(Player_GetStartingPosition(local_player), facing, OFFSET_FRONT, 20))
	UI_CreateMinimapBlip(Squad_GetPosition(squad), 10.0, "attack_here")

	-- Give it some oompf
	Modify_WeaponDamage(sg, "hardpoint_01", 2.5)
	Modify_WeaponAccuracy(sg, "hardpoint_01", 0.75)

	-- Spawn target(s)
	local sbp = SBP.GERMAN.ARMORED_CAR_GER
	if _skirmish.autoresolve > 0.5 then
		sbp = SBP.GERMAN.STUG_III_GER
	elseif _skirmish.autoresolve > 0.7 then
		sbp = SBP.GERMAN.PANZER_IV_CMD_GER
	end

	Util_CreateSquads(enemy_player, nil, sbp, Skirmish_GetMapEntryPosition(enemy_player), Player_GetStartingPosition(local_player), nil, nil, false, nil, nil, Util_ScarPos(0,0))

	bonus = {
		squad = squad,
		threshold = 1,
		count = 0,
		Title = _skirmish.narrative.event_fieldtest.obj_text, -- "Test modified anti-tank gun on enemy vehicles"
		Type = OT_Bonus,
		Intel_Start = function()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_fieldtest.start)
			CTRL.WAIT()
		end,
		OnStart = function()
			Skirmish_CreateMapBlip(bonus, bonus.squad)
			Rule_AddGlobalEvent(Skirmish_IncrementFieldTest, GE_EntityKilled)
		end,
		IsComplete = function()
			return bonus.count >= bonus.threshold
		end,
		IsFailed = function()
			return not Squad_IsAlive(bonus.squad)
		end,
		OnComplete = function()
			Skirmish_RemoveMapBlips(bonus)
			Rule_RemoveGlobalEvent(Skirmish_IncrementFieldTest)
		end,
		OnFail = function()
			Skirmish_RemoveMapBlips(bonus)
			Rule_RemoveGlobalEvent(Skirmish_IncrementFieldTest)
		end,
		Intel_Complete = function()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_fieldtest.done)
			CTRL.WAIT()
		end,
		Intel_Fail = function()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_fieldtest.fail)
			CTRL.WAIT()
		end,
	}
	Objective_Register(bonus)
	--Objective_SetCounter(bonus, bonus.count, bonus.threshold)
	Objective_Start(bonus, true, true)
end


-- Global event callback for GE_EntityKilled
function Skirmish_IncrementFieldTest(context)
	if context.victimOwner ~= nil and context.victimOwner == enemy_player and Entity_IsOfType(context.victim, "vehicle") then
		if context.killer and scartype(context.killer) == ST_ENTITY and bonus and bonus.squad == Entity_GetSquad(context.killer) then 
			bonus.count = bonus.count + 1
			--Objective_SetCounter(bonus, bonus.count, bonus.threshold)
		end
	end
end


-----------------------------------------------------------------------
-- Vehicle recovery bonus objective 
-----------------------------------------------------------------------
function Skirmish_StartRecovery(context, data)
	if Event_IsAnyRunning() then
		Rule_AddOneShot(Skirmish_StartRecovery, 2.0, data, bonus_rule)
		return
	end

	--Spawn empty vehicle and nearby squads
	local markers = Skirmish_GetMarkers("mkr_recovery", local_player, true)
	local marker = markers[World_GetRand(1, #markers)]
	local pos = Marker_GetPosition(marker)

	local ebp  = BP_GetEntityBlueprint("greyhound_recrewable_us")
	local sbp = SBP.AMERICAN.SCOUT_US
	if Player_GetRace(local_player) == RACE.BRITISH then
		ebp  = BP_GetEntityBlueprint("humber_recrewable_uk")
		sbp = SBP.BRITISH.TOMMY_UK
	elseif Player_HasUpgrade(local_player, BP_GetUpgradeBlueprint("airborne_company_us")) then
		sbp = SBP.AMERICAN.PATHFINDER_US
	end

	--local entity = Entity_CreateENVFacing(ebp, pos, World_GetOffsetPosition(pos, Marker_GetDirection(marker), OFFSET_LEFT, 10), true)
	local entity = Entity_CreateENVFacing(ebp, pos, World_GetOffsetPosition(pos, Marker_GetDirection(marker), OFFSET_FRONT, 10), true)
	Entity_Spawn(entity)
	local pct_health = 100 / Entity_GetHealthMax(entity)
	Entity_SetHealth(entity, pct_health)
	Entity_SetInvulnerableMinCap(entity, pct_health, 10.0)
	FOW_PlayerRevealEntity(local_player, entity, -1)

	local sg = SGroup_CreateUnique()
	local squad = Squad_CreateToward(sbp, allied_player, 1, World_GetOffsetPosition(pos, Marker_GetDirection(marker), OFFSET_LEFT, 2), World_Pos(0,0,1))
	Squad_Spawn(squad, World_GetOffsetPosition(pos, Marker_GetDirection(marker), OFFSET_BACK, 2.5), "none")
	Squad_SetHealth(squad, 0.5)
	Squad_SetInvulnerable(squad, true, 30.0)
	SGroup_Add(sg, squad)
	Rule_AddOneShot(Skirmish_DelayedRetreat, 5, {sg = sg})

	-- Simulate mine blast
	local offsets = {OFFSET_FRONT_LEFT, OFFSET_FRONT_RIGHT}
	local blast = Util_GetOffsetPosition(pos, offsets[World_GetRand(1,#offsets)], 2.5)
	Entity_SpawnLiveMunition(BP_GetWeaponBlueprint("105mm_howitzer_us"), Player_GetID(enemy_player), blast, blast)

	-- Enemy attack/ambush
	local sg_enemy = SGroup_CreateUnique()
	SGroup_Add(sg_enemy, Squad_CreateAndSpawnToward(SBP.GERMAN.PIONEER_GER, enemy_player, 0, Prox_GetRandomPosition(pos, 22, 18), pos))
	Cmd_AttackMove(sg_enemy, pos)
	SGroup_Destroy(sg_enemy)

	bonus = {
		target = entity,
		target_id = Entity_GetID(entity),
		squad = squad,
		sg = sg,
		Title = _skirmish.narrative.event_recovery.obj_text, -- "Return armored car to friendly territory"
		Type = OT_Bonus,
		Intel_Start = function()
			CTRL.Event_Delay(10)		-- Wait long enough for squad to begin retreat
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_recovery.start)
			CTRL.WAIT()
		end,
		OnStart = function()
			Skirmish_CreateMapBlip(bonus, bonus.target)
			Rule_AddEntityEvent(Skirmish_OnVehicleRecrewed, bonus.target, GE_EntityRecrewed)
			Rule_AddInterval(Skirmish_OnSquadRetreated, 2, {squad = bonus.squad}, mission_rule)
		end,
		IsComplete = function()
			return Entity_IsValid(bonus.target_id)
				and Entity_IsAlive(bonus.target) 
				and Entity_IsPartOfSquad(bonus.target)
				and Util_GetDistance(Entity_GetPosition(bonus.target), Player_GetStartingPosition(local_player)) < 45
		end,
		IsFailed = function()
			return not (Entity_IsValid(bonus.target_id) or Entity_IsAlive(bonus.target))
		end,
		OnComplete = function()
			Skirmish_RemoveMapBlips(bonus)
		end,
		OnFail = function()
			Skirmish_RemoveMapBlips(bonus)
		end,
		Intel_Complete = function()
			CTRL.Event_Delay(3)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_recovery.done)
			CTRL.WAIT()
		end,
		Intel_Fail = function()
			CTRL.Event_Delay(4)
			CTRL.WAIT()
			CTRL.Subtitle_PlayNarrativeEvent(_skirmish.narrative.event_recovery.fail)
			CTRL.WAIT()
		end,
	}
	Objective_Register(bonus)
	Objective_Start(bonus, true, true)
end

function Skirmish_DelayedRetreat(context, data)
	if data.sg and scartype(data.sg) == ST_SGROUP and SGroup_CountSpawned(data.sg) > 0 then
		Cmd_Retreat(data.sg)
	elseif data.squad and scartype(data.squad) == ST_SQUAD and Squad_IsAlive(data.squad) then
		if not Squad_IsRetreating(data.squad) then
			local sg = SGroup_CreateUnique()
			SGroup_Add(sg, data.squad)
			Cmd_Retreat(sg)
			SGroup_Destroy(sg)
		end
	end
end

-- Assign surviving allied squad to local player when finished retreat
function Skirmish_OnSquadRetreated(context, data)
	if Squad_IsAlive(data.squad) then
		if not Squad_IsRetreating(data.squad) then
			Rule_RemoveMe()
			Squad_SetPlayerOwner(data.squad, local_player)
		end
	else
		Rule_RemoveMe()
	end
end


function Skirmish_OnVehicleRecrewed(context)
	Rule_RemoveEntityEvent(Skirmish_OnVehicleRecrewed, context.entity)
	if Entity_GetPlayerOwner(context.entity) == local_player then
		Rule_AddOneShot(Skirmish_DelayedCritical, 0.5, {entity = context.entity}, mission_rule)
	else
		Objective_Fail(bonus, true, false)
	end
end

function Skirmish_DelayedCritical(context, data)
	if Entity_IsAlive(data.entity) then
		Entity_CompleteUpgrade(data.entity, BP_GetUpgradeBlueprint("engine_damage"))
		Rule_Add(Skirmish_RemoveCritical, {entity_id = Entity_GetID(data.entity), upgrade = BP_GetUpgradeBlueprint("engine_damage")}, mission_rule)
	end
end

-- Workaround for vehicle critical's applied through script never being removed through repair (BUG 99265).
function Skirmish_RemoveCritical(context, data)
	if not Entity_IsValid(data.entity_id) then
		Rule_RemoveMe()
	else
		local entity = Entity_FromID(data.entity_id)
		if not (Entity_IsAlive(entity) and Entity_HasUpgrade(entity, data.upgrade)) then
			Rule_RemoveMe()
		elseif Entity_GetHealthPercentage(entity) >= 0.9 then
			Entity_RemoveUpgrade(entity, data.upgrade)
			Rule_RemoveMe()
		end
	end
end


-----------------------------------------------------------------------
-- 
-----------------------------------------------------------------------