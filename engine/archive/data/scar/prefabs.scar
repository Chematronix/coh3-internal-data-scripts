--
-- PREFABS UTILITY SCRIPTS
--
-- Utilities for dealing with PREFAB data that comes from the World Builder.
--
-- Copyright 2016 SEGA Corporation, Developed by Relic Entertainment
--



--? @group scardoc;Prefab System

function FlattenPrefabTable(prefabTable, prefabLayersTable, scenarioType)
	local function AppendFlatten(node, flattened)
		if(node.instanceName ~= nil) then             
			local key = node.instanceName
			if(flattened[key] ~= nil) then
				error("Prefab data for '" .. scenarioType .. "' contains duplicate key '" .. key .. "'")
			end
			flattened[key] = node
		else
			local children = node.children or node
			for i, childNode in pairs(children) do
				AppendFlatten(childNode, flattened)
			end
		end
	end

	local flat = {}
	if scartype(prefabTable) == ST_TABLE then
		AppendFlatten(prefabTable, flat)
	end
	if scartype(prefabLayersTable) == ST_TABLE then
		for i,prefabLayerTable in ipairs(prefabLayersTable) do
			AppendFlatten(prefabLayerTable, flat)
		end
	end
	return flat
end

function FetchSchema(schemaName)
	
	local fullSchemaName = schemaName .. "_schema"
	local schema = _G[fullSchemaName]
	if(schema == nil) then
		local schemaFilePath = "prefabs//schema//" .. schemaName .. "_schema.scar"
		import(schemaFilePath)
		schema = _G[fullSchemaName]
	end
	
	
	return schema
	
end


function RequirementMet(requirement, prefabTable) 

	local operator = requirement.operator
	
	-- Old format {propertyName, possibleValueA, possibleValueB}
	if(operator == nil) then
		local dependentValue = prefabTable[requirement[1]]
		for requiredValueIndex = 2, #requirement do
			if(requirement[requiredValueIndex] == dependentValue) then
				return true
			end
		end
			
		return false
	end
	
	if(operator == "ANY") then
		for i, subRequirement in ipairs(requirement) do
			if(RequirementMet(subRequirement, prefabTable) == true) then
				return true
			end
		end
		
		return false
	elseif(operator == "ALL") then
		for i, subRequirement in ipairs(requirement) do
			if(RequirementMet(subRequirement, prefabTable) == false) then
				return false
			end
		end
		
		return true
	elseif(operator == "NOT") then
		for i, subRequirement in ipairs(requirement) do
			if(RequirementMet(subRequirement, prefabTable) == true) then
				return false
			end
		end
		
		return true
	end

	return false
end

function Sanitize(propertiesTable, itemSchema)
	for i, propertySchema in ipairs(itemSchema) do
		local propertyValue = propertiesTable[propertySchema.name]

		if(propertySchema.requirement ~= nil and RequirementMet(propertySchema.requirement, propertiesTable) == false) then
			propertiesTable[propertySchema.name] = nil
		else
			
			--Check if Sanitize needs to apply to table children
			if(propertySchema.itemSchema ~= nil) then
				if(propertySchema.multiplicity == "multiple") then
					for childIndex, child in ipairs(propertyValue) do
						Sanitize(child, propertySchema.itemSchema)
					end
				elseif(propertyValue ~= nil) then
					Sanitize(propertyValue, propertySchema.itemSchema)
				end
			end
		end
	end
end

function SanitizePrefabsAndSetDefaults(prefabTable)
	for prefabKey, prefab in pairs(prefabTable) do
		-- Make sure to resolve all default values prior to sanitizing, since
		-- RequirementsMet may depend on them.
		Prefab_ApplyDefaults(prefab)

		local prefabSchemaName = prefab.prefabName
		if(prefabSchemaName  ~= nil) then
			local schema = FetchSchema(prefabSchemaName )
			Sanitize(prefab, schema.itemSchema)
		end
	end
end

-- Initialize ALL prefab instances from the PrefabData table generated by the WorldBuilder. 
-- Also distributes instance data from a single global data table into seperate instance tables with the instance's names.
-- restore_table is an optional table. If it is passed in, Prefab_RestoreFromTable will be called with this table and the
-- prefab instance being initialized during Prefab_Init.
function Prefab_InitAll(restore_table)

	_Temp_PrefabData = nil
	
	local inScenref = true
	if scartype(_WorldBuilder_PrefabData_reference) ~= ST_TABLE and scartype(_WorldBuilder_Layer_PrefabData_reference) ~= ST_TABLE then
		-- not in scenref (or scenref prefabdata deleted)
		inScenref = false
	end

	_WorldBuilder_PrefabData = FlattenPrefabTable(_WorldBuilder_PrefabData, _WorldBuilder_Layer_PrefabData, "Scenario")
	_WorldBuilder_Layer_PrefabData = nil
	SanitizePrefabsAndSetDefaults(_WorldBuilder_PrefabData)
	
	if scartype(_MissionScript_PrefabData) ~= ST_TABLE then
		_MissionScript_PrefabData = {}
	end
	if scartype(_ActivePrefabs_PrefabData) ~= ST_TABLE then
		_ActivePrefabs_PrefabData = {}
	end
	if scartype(_PrefabPostInitList) ~= ST_TABLE then
		_PrefabPostInitList = {}
	end
	if scartype(_PrefabPresetCompleteList) ~= ST_TABLE then
		_PrefabPresetCompleteList = {}
	end
	if scartype(_PrefabPrerollList) ~= ST_TABLE then
		_PrefabPrerollList = {}
	end

	for name, data in Table_DeterministicOrderedPairs(_WorldBuilder_PrefabData) do 
		
		if not inScenref or data.inScenRef then
			
			local newInstance = Clone(data)
			_G[name] = newInstance
			
			Prefab_Init(newInstance, restore_table)
			
		end
	end

	_WorldBuilder_PrefabData_reference = FlattenPrefabTable(_WorldBuilder_PrefabData_reference, _WorldBuilder_Layer_PrefabData_reference, "Scenario Reference")
	_WorldBuilder_Layer_PrefabData_reference = nil
	
	SanitizePrefabsAndSetDefaults(_WorldBuilder_PrefabData_reference)

	for name, data in Table_DeterministicOrderedPairs(_WorldBuilder_PrefabData_reference) do 
		
		local newInstance = Clone(data)
		local i = 2
		local basename = name
		while (_G[name] == ST_TABLE) do
			name = basename..tostring(i)
			i = i + 1
		end
		_G[name] = newInstance
		
		Prefab_Init(newInstance, restore_table)
		
	end
	
	Prefab_ForcePostInit()
	
	__prefabDebug = false
	
	-- set the prefab scripts to be reloaded upon a mission restore
	Game_SetGameRestoreCallback(Prefab_ReloadAll)
	
end

--? @args Void
--? @result Void
--? @shortdesc Called after Preset is called on all modules
function Prefab_PresetComplete()
	for index, item in pairs(_PrefabPresetCompleteList) do
		item.func(item.instance)
	end
	_PrefabPresetCompleteList = {}
end

--? @args Table instance_data, Table restore_table
--? @result String instanceName
--? @shortdesc Initialize a specific prefab instance. In many cases, this is all you need to do (see the documentation for the specific prefab for details)
--? @extdesc restore_table can be passed optionally to provoke the prefab type specific RestoreFromTable to be called before the type specific init function.
function Prefab_Init(instance, restore_table)
	
	instance.prefabName = Prefab_GetAliasName(instance.prefabName)
	
	-- if the prefab script/schema has not been loaded yet, load it now
	Prefab_Load(instance.prefabName)
	
	--  make sure this instance has a backup, so it can be reset, etc
	local instanceName = instance.instanceName
	
	-- check to see if the instance is script-built (i.e. not from the World Builder)
	if instanceName == nil or (_WorldBuilder_PrefabData[instanceName] == nil and _MissionScript_PrefabData[instanceName] == nil and _WorldBuilder_PrefabData_reference[instanceName] == nil) then
		
		-- generate a unique name for this instance
		instanceName = Prefab_GenerateUniqueInstanceName(instance)
		instance.instanceName = instanceName
	
		-- add this instance data to the MissionScript table so it can be retrieved again (i.e. for a reset)
		_MissionScript_PrefabData[instanceName] = Clone(instance)
		_G[instanceName] = instance
	
	end
	
	local conditionFunction = _G[instance.prefabName.."_Condition"]
	if scartype(conditionFunction) == ST_FUNCTION then
		if not conditionFunction(instance) then
			return -- Do not load this prefab
		end
	end
	
	if scartype(restore_table) == ST_TABLE then
		local restoreFunction = _G[instance.prefabName.."_RestoreFromTable"]
		if scartype(restoreFunction) == ST_FUNCTION then
			restoreFunction(instance, restore_table)
		end
	end

	local initFunction = _G[instance.prefabName.."_Init"]
	initFunction(instance)
	
	local postInitFunction = _G[instance.prefabName.."_PostInit"]
	if scartype(postInitFunction) == ST_FUNCTION then
		table.insert(_PrefabPostInitList, {instance = instance, func = postInitFunction})
		if Rule_Exists(Prefab_ForcePostInit) == false then
			Rule_AddOneShot(Prefab_ForcePostInit, 0.1)
		end
	end
	
	local presetCompleteFunction = _G[instance.prefabName.."_PresetComplete"]
	if scartype(presetCompleteFunction) == ST_FUNCTION then
		table.insert(_PrefabPresetCompleteList, {instance = instance, func = presetCompleteFunction})
	end
	
	if instance.prefabName == "prerolldestruction" then
		table.insert(_PrefabPrerollList, instance)
	end
	
	_ActivePrefabs_PrefabData[instanceName] = instance		-- Adds to a global table of prefabs
	
	return instanceName
	
end



--? @args Void
--? @result Void
--? @shortdesc Finalize the initialization of any prefab instances that have been run through Prefab_Init(). This is automatically called one frame after a prefab is initialized, but you can force it early if necessary.
--? @extdesc If you are creating prefabs and using them in the same frame, call this function once, after all the Prefab_Inits, but before you start using them. This will force the post-initialization to occur early.
function Prefab_ForcePostInit()

	for index, item in pairs(_PrefabPostInitList) do
		
		item.func(item.instance)
		
	end
	
	_PrefabPostInitList = {}
	
end

function Prefab_HasPreroll()
	return next(_PrefabPrerollList) ~= nil
end

function Prefab_GetPrerollDuration()
	local totalDuration = 0;
	for index, item in pairs(_PrefabPrerollList) do
		totalDuration = math.max(totalDuration, item.duration)
	end
	return totalDuration
end

function Prefab_DoPreroll()
	for index, item in pairs(_PrefabPrerollList) do
		Prefab_Trigger(item)
	end
end


--? @args Table/String instance_data,  Table prefab_schema
--? @shortdesc Applies the defaults listed in the prefab schema to the instance data. Any items NOT included explicitly in the instance data will have default values pulled from the schema.
function Prefab_ApplyDefaults(instance)

	local prefabSchema = _G[string.lower(instance.prefabName.."_schema")]						-- find the schema for this prefab instance
	Prefab_ApplySchemaToDataTable(prefabSchema.itemSchema, instance)	-- apply the schema to the instance data
	
end



--? @args Table/String instance_data,  Table prefab_schema
--? @shortdesc Returns a table of all current prefabs matching the instance type
function Prefab_GetAllOfType(prefabType)
	
	local t = {}
	
	if scartype(prefabType) == ST_NIL then
		-- Return all instances
		return _ActivePrefabs_PrefabData
	else
		for k,v in pairs(_ActivePrefabs_PrefabData) do
			if v.prefabName == prefabType then
				table.insert(t, v)
			end
		end
		return t
	end
	
end


--? @args String prefabType
--? @shortdesc Returns a table of all current prefabs matching the instance type where the key to each entry in the table is the name of the prefab
function Prefab_GetNameSetOfType(prefabType)
	
	local t = {}

	for k,v in pairs(_ActivePrefabs_PrefabData) do
		if v.prefabName == prefabType then
			local instance = Prefab_GetInstance(v)
			if instance.instanceName ~= nil then
				t[instance.instanceName] = v
			end
		end
	end
	
	return t
end



--? @args Table/String instance
--? @result InstanceData
--? @shortdesc Returns the instance data for a given instance, specified by a number of methods.
--? @extdesc This normalizes your instance data. You can pass in the instance name as a string, a data table with an instance subtable (i.e. the input params from an event function) or a real instance data table, and it normalizes the format and returns you the instance data table.
function Prefab_GetInstance(input)

	if scartype(input) == ST_STRING then
		
		return _G[input]								-- we got the instance name as a string, so look up the global variable for the instance data
		
	elseif scartype(input) == ST_TABLE then
		
		if input.instance ~= nil then
			
			return input.instance						-- we got a data table from an event, the data we want is in the instance field, so return that
			
		else
			
			return input									-- we got a different kind of table... assume it was an instance data table anyway, so return it as is
			
		end
		
	end

end

--? @args String instance
--? @result Boolean
--? @shortdesc Returns if a String is a valid prefab
function Prefab_IsValid(input)
	
	if scartype(input) == ST_STRING then
		
		return scartype(_G[input]) == ST_TABLE								-- we got the instance name as a string, so look up the global variable for the instance data
		
	end

end

--? @args Table/String instance_data
--? @result Boolean
--? @shortdesc Checks if a prefab instance is currently running 
--? @extdesc If the prefab has a prefabName_IsActive() function, that will be called. Otherwise, an error will be thrown
function Prefab_IsActive(data)

	local instance = Prefab_GetInstance(data)
	
	local instanceName = instance.instanceName
	local prefabName = instance.prefabName
	
	-- call the prefab's IsActive function if there is one
	local IsActive = _G[prefabName.."_IsActive"]
	if scartype(IsActive) == ST_FUNCTION then
		return IsActive(instance)
	else
		error("Prefab type ["..prefabName.."] does not have an associated IsActive function")
	end
end





--? @args Table/String instance_data
--? @shortdesc Stops a prefab instance from continuing to run. 
--? @extdesc If the prefab has a prefabName_Stop() function, that will be called. Also, all events with the instance as the data parameter will be removed.
function Prefab_Stop(data)

	local instance = Prefab_GetInstance(data)
	
	local instanceName = instance.instanceName
	local prefabName = instance.prefabName
	
	-- call the prefab's Stop function if there is one
	local stop = _G[prefabName.."_Stop"]
	if scartype(stop) == ST_FUNCTION then
		stop(instance)
	end
	
	-- kill any events associated with this instance
	if instance.proximityEventId then
		Rule_RemoveWithID(instance.proximityEventId)
	end
	
end



--? @args Table/String instance_data
--? @shortdesc Stop and restart a prefab instance, pulling a fresh set of the instance data from the WB-exported prefabs. This is meant for testing and debug purposes, rather than use in mission scripts.
function Prefab_Reset(data)

	local instance = Prefab_GetInstance(data)

	local instanceName = instance.instanceName
	local prefabName = instance.prefabName
	
	-- stop the old instance running
	Prefab_Stop(instance)
	
	-- move a fresh copy of the instance data from the instance prefab data table into the variable 
	local newInstance = nil
	if scartype(_WorldBuilder_PrefabData) == ST_TABLE and _WorldBuilder_PrefabData[instanceName] ~= nil then
		newInstance = Clone(_WorldBuilder_PrefabData[instanceName])
	elseif scartype(_MissionScript_PrefabData) == ST_TABLE and _MissionScript_PrefabData[instanceName] ~= nil then
		newInstance = Clone(_MissionScript_PrefabData[instanceName])
	else
		return
	end
	
	_G[instanceName] = newInstance
	
	-- run Init on the new instance
	Prefab_Init(newInstance)
	
end



--? @args Table/String instance_data, String actionName[, Var param1, Var param2...]
--? @shortdesc Calls an action function with a given name on an instance, making sure it calls the right version for the type of Prefab. Instance can be a string, this will convert it.
--? @extdesc Example: Calling the "Trigger" action on an instance that is a PlaneCrash prefab will look for a function called "PlaneCrash_Trigger"
function Prefab_DoAction(...)
	
	local arg = {...}
	local data = arg[1]
	local actionName = arg[2]

	local instance = Prefab_GetInstance(data)
	
	if scartype(instance) == ST_TABLE then
	
		local prefabName = instance.prefabName
		
		if scartype(prefabName) == ST_STRING and scartype(actionName) == ST_STRING  then
			
			local prefabFunctionName = prefabName.."_"..actionName
			local prefabFunction = _G[prefabFunctionName]
			
			if scartype(prefabFunction) == ST_FUNCTION then

				if #arg == 2 then 		-- Call the function along with any parameters passed in (shifted by two since arg[1] is the instance and arg[2] is the action name)
					return prefabFunction(instance)
				elseif #arg == 3 then
					return prefabFunction(instance, arg[3])
				elseif #arg == 4 then
					return prefabFunction(instance, arg[3], arg[4])
				elseif #arg == 5 then
					return prefabFunction(instance, arg[3], arg[4], arg[5])
				elseif #arg == 6 then
					return prefabFunction(instance, arg[3], arg[4], arg[5], arg[6])
				elseif #arg == 7 then
					return prefabFunction(instance, arg[3], arg[4], arg[5], arg[6], arg[7])
				elseif #arg == 8 then
					return prefabFunction(instance, arg[3], arg[4], arg[5], arg[6], arg[7], arg[8])
				elseif #arg == 9 then
					return prefabFunction(instance, arg[3], arg[4], arg[5], arg[6], arg[7], arg[8], arg[9])
				elseif #arg == 10 then
					return prefabFunction(instance, arg[3], arg[4], arg[5], arg[6], arg[7], arg[8], arg[9], arg[10])
				else
					fatal("Prefab_DoAction: Too many parameters! You'll need to add support for more in Prefabs.scar")
				end							
				
			else
				
				prefabprint(prefabFunctionName.."() does not exist")
				
			end
			
		end
		
	else
		
		if scartype(data) == ST_STRING then
			prefabprint("Prefab_DoAction: No instance named "..data.." found")
		else
			prefabprint("Prefab_DoAction: No instance found")
		end
		
	end
	
end



--? @args Table/String instance_data
--? @shortdesc Triggers the specified prefab
function Prefab_Trigger(data)
	Prefab_DoAction(data, "Trigger")
end


function prefabprint(info)
	if __prefabDebug then
		print(info)
	end
end


--
-- INTERNAL FUNCTIONS 
--




-- generate a unique instance name for this instance
-- will be of the form <prefabName>_Instance<number>
function Prefab_GenerateUniqueInstanceName(data)

	local instance = Prefab_GetInstance(data)
	
	if _Prefabs_NewInstanceNumber == nil then
		_Prefabs_NewInstanceNumber = 1
	else
		_Prefabs_NewInstanceNumber = _Prefabs_NewInstanceNumber + 1
	end
	
	return instance.prefabName.."_PrefabInstance".._Prefabs_NewInstanceNumber

end



-- The WorldBuilder reset button hooks up to this function
-- This is because it only knows the the instance by it's name, rather than as an instance data table. 
-- This function converts it, and then calls the real Prefab_Restart function
function Prefab_ResetFromWorldBuilder(data)

	--
	-- To-do: reload the WorldBuilder-exported prefab data table
	--
	
	local instance = Prefab_GetInstance(data)
	
	if scartype(instance) == ST_TABLE and instance.instanceName == data then
		Prefab_Restart(instance)
	end
	
end

-- Move value at key alias to primaryName if primaryName has no value
function Prefab_ApplyAlias(data, primaryName, aliases)
	if data[primaryName] == nil and aliases ~= nil then	
		for index,alias in ipairs(aliases) do
			if data[alias] ~= nil then
				data[primaryName] = data[alias]
				data[alias] = nil
				break
			end	
		end
	end
end

-- Applies a schema to one level of a data table
-- Calls itself recursively to deal with deep tables
function Prefab_ApplySchemaToDataTable(schemaTable, data)

	-- loop through items _in the schema_
	for index, schema in pairs(schemaTable) do
		
		Prefab_ApplyAlias(data, schema.name, schema.aliases)
		
		-- if the data has no matching item for this key, insert the default (if there is one!)
		if data[schema.name] == nil then
			if schema.default ~= nil then
				data[schema.name] = schema.default
			elseif schema.type == ST_TABLE then
				data[schema.name] = {}
			end
		end
		
		-- swap data elements from strings to real items according to their schema type
		data[schema.name] = Prefab_ReplaceDataWithProperType(data[schema.name], schema)
		
		-- if the item is a table, run this function on that sub-set of the schema and data
		if schema.type == ST_TABLE and scartype(data[schema.name]) == ST_TABLE and scartype(schema.itemSchema) == ST_TABLE then
		
			if schema.multiplicity == "multiple" then
				for subindex, subitem in pairs(data[schema.name]) do
					Prefab_ApplySchemaToDataTable(schema.itemSchema, subitem)
				end
			elseif schema.multiplicity == "single" then
				Prefab_ApplySchemaToDataTable(schema.itemSchema, data[schema.name])
			end

		end
		
	end
	
end



-- Items come in/out of the worldbuilder as strings in the data table. 
-- This function converts a string representation of a player, marker, etc, to a proper type.
function Prefab_ReplaceDataWithProperType(data, schema)

	if scartype(data) == ST_STRING and schema.type ~= ST_STRING then
		
		-- if the data is a string, but the schema type ISN'T a string, then we have some string -> data type conversion to do
		
		if schema.type == ST_PLAYER then
			
			if string.sub(data, 0, 6) == "Player" then
				if string.sub(data, 7, 7) == " " then
					return World_GetPlayerAt(tonumber(string.sub(data, 8, 8))) -- get the player index by just grabbing the X in "Player X"
				else
					return World_GetPlayerAt(tonumber(string.sub(data, 7, 7)))
				end
			elseif data.name == "World" then
				return nil
			end

		elseif schema.type == ST_PBG then
			
			if data == nil or data == "" then
				return nil
			elseif schema.blueprintType == "squad" then
				return BP_GetSquadBlueprint(data)
			elseif schema.blueprintType == "entity" then
				return BP_GetEntityBlueprint(data)
			elseif schema.blueprintType == "upgrade" then
				return BP_GetUpgradeBlueprint(data)
			elseif schema.blueprintType == "ability" then
				return BP_GetAbilityBlueprint(data)
			elseif schema.blueprintType == "pass_type" then
				return BP_GetPassTypeBlueprint(data)
			elseif schema.blueprintType == "map_pool" then
				return BP_GetMapPoolBlueprint(data)
			elseif schema.blueprintType == "race" then
				return World_GetRaceBlueprint(data)
			elseif schema.blueprintType == "weapon" then
				return BP_GetWeaponBlueprint(data)
			end
			
		elseif schema.type == ST_EGROUP then
			
			if data == "" then
				return nil
			else
				return EGroup_CreateIfNotFound(data)
			end
			
		elseif schema.type == ST_SGROUP then
			
			if data == "" then
				return nil
			else
				return SGroup_CreateIfNotFound(data)
			end
			
		elseif schema.type == "ST_LOCSTRING"	then		-- this isn't actually a thing yet, TODO: finish this off sometime
			
			if string.sub(data, 0, 1) == "$" then
				return string.sub(data, 1)
			else
				return LOC(data)
			end
			
		end
		
	elseif schema.type == ST_MARKER and scartype(data) == ST_TABLE then
		local marker = Marker_Create(data.name, "Prefab", World_Pos(data.posx, data.posy, data.posz), World_Pos(data.dirx, data.diry, data.dirz), 0)

		if data.shape == nil or data.shape == "circle" then
			Marker_SetProximityCircle(marker, data.rad)
		elseif data.shape == "rectangle" then
			Marker_SetProximityRectangle(marker, data.width, data.depth)
		elseif data.shape == "point" then
			Marker_SetProximityPoint(marker)
		end

		return marker
	end
	
	-- default
	return data

end



function Prefab_GetAliasName(prefabName)
	-- Check Alias
	if scartype(_G.prefabs_config) ~= ST_TABLE then
		import("Prefabs/prefabs_config.scar")
	end
	
	if(_G.prefabs_config.schema_aliases ~= nil) then
		prefabName = _G.prefabs_config.schema_aliases[prefabName] or prefabName
	end
	
	return prefabName
end

-- 
function Prefab_Load(prefabName)

	prefabName = Prefab_GetAliasName(prefabName)
	
	if scartype(_G[string.lower(prefabName.."_schema")]) ~= ST_TABLE then
		
		import("Prefabs/Schemas/"..prefabName..".scar")
		import("Prefabs/Schemas/"..prefabName.."_schema.scar")
		
		if _Prefabs_UsedPrefabList == nil then
			_Prefabs_UsedPrefabList = {prefabName}
		else
			table.insert(_Prefabs_UsedPrefabList, prefabName)
		end
		
	end

end

-- make sure that any prefab script that has been used in the mission gets re-imported
function Prefab_ReloadAll()

	if scartype(_Prefabs_UsedPrefabList) == ST_TABLE then
		
		for index, prefabName in pairs(_Prefabs_UsedPrefabList) do
			
			prefabprint("Reloading prefab "..prefabName)
			
			import("Prefabs/Schemas/"..prefabName..".scar")
			import("Prefabs/Schemas/"..prefabName.."_schema.scar")
			
		end
		
	end
	
end

Prefab_ReloadAll()	-- reload prefabs when you hit the reload scripts button







--
-- HELPER FUNCTIONS 
--



--? @args Table/String instance_data, String action_name, Table trigger_parameters
--? @shortdesc Add this helper function to your prefab's Init function to cover standard trigger zone functionality. 
--? @extdesc It will call a Trigger function in your prefab when appropriate. Your schema needs to include the standard elements: trigger_enable, ignore_planes, trigger_player, trigger_zone and delay
function PrefabHelper_StandardTriggerSystem(data,  action_name, trigger_parameters)

	local instance = Prefab_GetInstance(data)

	if trigger_parameters == nil then 
		trigger_parameters = instance
	end
	
	local event_data = {instance = instance}
	
	if trigger_parameters.ignore_planes == true then
		event_data.filterlist = LIST.AIRCRAFT
		event_data.filtertype = FILTER_REMOVE
	end
	
	if trigger_parameters.ignore_camouflage == true then
		event_data.ignore_camouflage = true
	end
	
	if trigger_parameters.delay == nil then
		trigger_parameters.delay = 0.0
	end
	
	if action_name == nil then
		event_data.action_name = "Trigger"
	else
		event_data.action_name = action_name
	end
	
	instance.proximityEventId = Event_Proximity(PrefabHelper_StandardTriggerSystem_Trigger, event_data, trigger_parameters.trigger_player, trigger_parameters.trigger_zone, Marker_GetProximityRadiusOrDefault(trigger_parameters.trigger_zone, 0), trigger_parameters.delay)
	
end

function PrefabHelper_StandardTriggerSystem_Trigger(data)

	local instance = Prefab_GetInstance(data)

	Prefab_DoAction(instance, data.action_name)
	
end
